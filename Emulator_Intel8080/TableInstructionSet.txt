0#NOP#-----#1#4#Нет операции.
1#LXI B,b16#-----#3#10#Загружает двух байтовое число в пару регистров BC.
1#STAX B#-----#1#7#Сохраняет значение А в памяти по адресу пары регистров BC.
2#INX B#-----#1#5#Добавляет единицу двух байтовому числу состоящему из пары регистров BC. [BC] = [BC] + 1
2#INR B#++++-#1#5#Добавляет единицу одно байтовому числу состоящему из регистра B. [B] = [B] + 1
2#DCR B#++++-#1#5#Вычитает единицу из одно байтвого числа состоящего из регистра B. [B] = [B] - 1
1#MVI B,b8#-----#2#7#Присваевает однобайтовое число(b8), регистру B. [B] = (b8)
2#RLC#----+#1#4#Все биты регистра А сдвигаются влево на один бит. Значение последнего бита устанавливается в флаг переноса(Carry) и устанавливается в первый бит регистра А.
4
2#DAD B#----+#1#10#Добавляет двух байтовое число, которое образует пара регистров BC, к паре регистров HL. [HL] = [HL] + [BC] 
1#LDAX B#-----#1#7#Загружает число по адресу пары регистров BC в регистр А.
2#DCX B#-----#1#5#Вычитает единицу из двухбайтового числа состоящего из пары регистров BC. [BC] = [BC] - 1
2#INR C#++++-#1#5#Добавляет единицу одно байтовому числу состоящему из регистра С. [C] = [C] + 1
2#DCR C#++++-#1#5#Вычитает единицу из одно байтвого числа состоящего из регистра C. [C] = [C] - 1
1#MVI C,b8#-----#2#7#Присваевает однобайтовое число(b8), регистру С. [C] = (b8)
2#RRC#----+#1#4#Все биты регистра А сдвигаются вправо на один бит. Значение первого бита регистра А устанавливается в флаг переноса(Carry) и устанавливается в последний бит регистра А.
4
1#LXI D,b16#-----#3#10#Загружает двух байтовое число в пару регистров DE.
1#STAX D#-----#1#7#Сохраняет значение А в памяти по адресу пары регистров DE.
2#INX D#-----#1#5#Добавляет единицу двух байтовому числу состоящему из пары регистров DE. [DE] = [DE] + 1
2#INR D#++++-#1#5#Добавляет единицу одно байтовому числу состоящему из регистра D. [D] = [D] + 1
2#DCR D#++++-#1#5#Вычитает единицу из одно байтвого числа состоящего из регистра D. [D] = [D] - 1
1#MVI D,b8#-----#2#7#Присваевает однобайтовое число(b8), регистру D. [D] = (b8)
2#RAL#----+#1#4#Все биты регистра А сдвигаются влево на один бит. Состояние флага переноса(Carry) устанавливается в первый бит регистра А. Значение последнего бита  (не сдвинутого регистра А) устанавливается в флаг переноса(Carry).
4
2#DAD D#----+#1#10#Добавляет двух байтовое число, которое образует пара регистров DE, к паре регистров HL. [HL] = [HL] + [DE] 
1#LDAX D#-----#1#7#Загружает число по адресу пары регистров DE в регистр А.
2#DCX D#-----#1#5#Вычитает единицу из двухбайтового числа состоящего из пары регистров DE. [DE] = [DE] + 1
2#INR E#++++-#1#5#Добавляет единицу одно байтовому числу состоящему из регистра E. [E] = [E] + 1
2#DCR E#++++-#1#5#Вычитает единицу из одно байтвого числа состоящего из регистра E. [E] = [E] - 1
1#MVI E,b8#-----#2#7#Присваевает однобайтовое число(b8), регистру E. [E] = (b8)
2#RAR#----+#1#4#Все биты регистра А сдвигаются вправо на один бит.Состояние флага переноса(Carry) устанавливается в последний бит регистра А. Значение первого бита (не сдвинутого регистра А) устанавливается в флаг переноса(Carry).
4
1#LXI H,b16#-----#3#10#Загружает двух байтовое число в пару регистров HL.
1#SHLD b16#-----#3#16#Сохраняет значение пары регистров HL в память по адресу (b16).
2#INX H#-----#1#5#Добавляет единицу двух байтовому числу состоящему из пары регистров HL. [HL] = [HL] + 1
2#INR H#++++-#1#5#Добавляет единицу одно байтовому числу состоящему из регистра H. [H] = [H] + 1
2#DCR H#++++-#1#5#Вычитает единицу из одно байтвого числа состоящего из регистра H. [H] = [H] - 1
1#MVI H,b8#-----#2#7#Присваевает однобайтовое число(b8), регистру H. [H] = (b8)
4
4
2#DAD H#----+#1#10#Добавляет двух байтовое число, которое образует пара регистров HL, к паре регистров HL. [HL] = [HL] + [HL] 
1#LHLD b16#-----#3#16#Загружает значение из памяти по адресу (b16) в пару регистров HL.
2#DCX H#-----#1#5#Вычитает единицу из двухбайтового числа состоящего из пары регистров HL. [HL] = [HL] - 1
2#INR L#++++-#1#5#Добавляет единицу одно байтовому числу состоящему из регистра L. [L] = [L] + 1
2#DCR L#++++-#1#5#Вычитает единицу из одно байтвого числа состоящего из регистра L. [L] = [L] - 1
1#MVI L,b8#-----#2#7#Присваевает однобайтовое число(b8), регистру L. [L] = (b8)
2#CMA#-----#1#4#Инвентирует побитово значение регистра А. [A] = ![A]
4
1#LXI SP,b16#-----#3#10#Загружает двух байтовое число в указатель стека SP.
1#STA b16#-----#3#13#Сохраняет значение регистра A в память по адресу (b16). M[(b16)] = [A]
2#INX SP#-----#1#5#Добавляет единицу двух байтовому числу состоящему из указателя стека SP. [SP] = [SP] + 1
2#INR M#++++-#1#10#Добавляет единицу одно байтовому числу, хранящемуся в памяти по адресу пары регистров HL. M[H][L] = M[H][L] + 1
2#DCR M#++++-#1#10#Вычитает единицу из элемента памяти, которые находится по адресу пары регистров HL. M[H][L] = M[H][L] - 1
1#MVI M,b8#-----#2#10#Присваевает однобайтовое число(b8), памяти по адресу пары регистров HL. M[H][L] = (b8)
2#STC#----1#1#4#Устанавливает флаг переноса в состояние [1]. [Carry] = 1
4
2#DAD SP#----+#1#10#Добавляет двух байтовое число, которое образует указатель стека SP, к паре регистров HL. [HL] = [HL] + [SP] 
1#LDA b16#-----#3#13#Загружает значение из памяти по адресу (b16) в регистр A. [A] = M[(b16)]
2#DCX SP#-----#1#5#Вычитает единицу из указателя стэка SP. [SP] = [SP] - 1
2#INR A#++++-#1#5#Добавляет единицу одно байтовому числу состоящему из регистра A. [A] = [A] + 1
2#DCR A#++++-#1#5#Вычитает единицу из одно байтвого числа состоящего из регистра A. [A] = [A] - 1
1#MVI A,b8#-----#2#7#Присваевает однобайтовое число(b8), регистру A. [A] = (b8)
2#CMC#----+#1#4#Инвентирует флаг переноса.  [Carry] = ![Carry]
1#MOV B,B#-----#1#5#Значение регистра B присваивается регистру B.   [B] = [B]
1#MOV B,C#-----#1#5#Значение регистра C присваивается регистру B.   [B] = [C]
1#MOV B,D#-----#1#5#Значение регистра D присваивается регистру B.   [B] = [D]
1#MOV B,E#-----#1#5#Значение регистра E присваивается регистру B.   [B] = [E]
1#MOV B,H#-----#1#5#Значение регистра H присваивается регистру B.   [B] = [H]
1#MOV B,L#-----#1#5#Значение регистра L присваивается регистру B.   [B] = [L]
1#MOV B,M#-----#1#7#Значение памяти по адресу пары регистров HL, присваивается регистру B. [B] = M[H][L], M - память
1#MOV B,A#-----#1#5#Значение регистра A присваивается регистру B.   [B] = [A]
1#MOV C,B#-----#1#5#Значение регистра B присваивается регистру C.   [C] = [B]
1#MOV C,C#-----#1#5#Значение регистра C присваивается регистру C.   [C] = [C]
1#MOV C,D#-----#1#5#Значение регистра D присваивается регистру C.   [C] = [D]
1#MOV C,E#-----#1#5#Значение регистра E присваивается регистру C.   [C] = [E]
1#MOV C,H#-----#1#5#Значение регистра H присваивается регистру C.   [C] = [H]
1#MOV C,L#-----#1#5#Значение регистра L присваивается регистру C.   [C] = [L]
1#MOV C,M#-----#1#7#Значение памяти по адресу пары регистров HL, присваивается регистру C. [C] = M[H][L], M - память
1#MOV C,A#-----#1#5#Значение регистра A присваивается регистру C.   [C] = [A]
1#MOV D,B#-----#1#5#Значение регистра B присваивается регистру D.   [D] = [B]
1#MOV D,C#-----#1#5#Значение регистра C присваивается регистру D.   [D] = [C]
1#MOV D,D#-----#1#5#Значение регистра D присваивается регистру D.   [D] = [D]
1#MOV D,E#-----#1#5#Значение регистра E присваивается регистру D.   [D] = [E]
1#MOV D,H#-----#1#5#Значение регистра H присваивается регистру D.   [D] = [H]
1#MOV D,L#-----#1#5#Значение регистра L присваивается регистру D.   [D] = [L]
1#MOV D,M#-----#1#7#Значение памяти по адресу пары регистров HL, присваивается регистру D. [D] = M[H][L], M - память
1#MOV D,A#-----#1#5#Значение регистра A присваивается регистру D.   [D] = [A]
1#MOV E,B#-----#1#5#Значение регистра B присваивается регистру E.   [E] = [B]
1#MOV E,C#-----#1#5#Значение регистра C присваивается регистру E.   [E] = [C]
1#MOV E,D#-----#1#5#Значение регистра D присваивается регистру E.   [E] = [D]
1#MOV E,E#-----#1#5#Значение регистра E присваивается регистру E.   [E] = [E]
1#MOV E,H#-----#1#5#Значение регистра H присваивается регистру E.   [E] = [H]
1#MOV E,L#-----#1#5#Значение регистра L присваивается регистру E.   [E] = [L]
1#MOV E,M#-----#1#7#Значение памяти по адресу пары регистров HL, присваивается регистру E. [E] = M[H][L], M - память
1#MOV E,A#-----#1#5#Значение регистра A присваивается регистру E.   [E] = [A]
1#MOV H,B#-----#1#5#Значение регистра B присваивается регистру H.   [H] = [B]
1#MOV H,C#-----#1#5#Значение регистра C присваивается регистру H.   [H] = [C]
1#MOV H,D#-----#1#5#Значение регистра D присваивается регистру H.   [H] = [D]
1#MOV H,E#-----#1#5#Значение регистра E присваивается регистру H.   [H] = [E]
1#MOV H,H#-----#1#5#Значение регистра H присваивается регистру H.   [H] = [H]
1#MOV H,L#-----#1#5#Значение регистра L присваивается регистру H.   [H] = [L]
1#MOV H,M#-----#1#7#Значение памяти по адресу пары регистров HL, присваивается регистру H. [H] = M[H][L], M - память
1#MOV H,A#-----#1#5#Значение регистра A присваивается регистру H.   [H] = [A]
1#MOV L,B#-----#1#5#Значение регистра B присваивается регистру L.   [L] = [B]
1#MOV L,C#-----#1#5#Значение регистра C присваивается регистру L.   [L] = [C]
1#MOV L,D#-----#1#5#Значение регистра D присваивается регистру L.   [L] = [D]
1#MOV L,E#-----#1#5#Значение регистра E присваивается регистру L.   [L] = [E]
1#MOV L,H#-----#1#5#Значение регистра H присваивается регистру L.   [L] = [H]
1#MOV L,L#-----#1#5#Значение регистра L присваивается регистру L.   [L] = [L]
1#MOV L,M#-----#1#7#Значение памяти по адресу пары регистров HL, присваивается регистру L. [L] = M[H][L], M - память
1#MOV L,A#-----#1#5#Значение регистра A присваивается регистру L.   [L] = [A]
1#MOV M,B#-----#1#7#Значение регистра B присваивается памяти по адресу пары регистров HL.   M[H][L] = [B], M - память
1#MOV M,C#-----#1#7#Значение регистра C присваивается памяти по адресу пары регистров HL.   M[H][L] = [C], M - память
1#MOV M,D#-----#1#7#Значение регистра D присваивается памяти по адресу пары регистров HL.   M[H][L] = [D], M - память
1#MOV M,E#-----#1#7#Значение регистра E присваивается памяти по адресу пары регистров HL.   M[H][L] = [E], M - память
1#MOV M,H#-----#1#7#Значение регистра H присваивается памяти по адресу пары регистров HL.   M[H][L] = [H], M - память
1#MOV M,L#-----#1#7#Значение регистра L присваивается памяти по адресу пары регистров HL.   M[H][L] = [L], M - память
0#HLT#-----#1#7#Приостанавливает работу процессора до тех пор, пока не произойдет сброс.
1#MOV M,A#-----#1#7#Значение регистра A присваивается памяти по адресу пары регистров HL.   M[H][L] = [A], M - память
1#MOV A,B#-----#1#5#Значение регистра B присваивается регистру A.   [A] = [B]
1#MOV A,C#-----#1#5#Значение регистра C присваивается регистру A.   [A] = [C]
1#MOV A,D#-----#1#5#Значение регистра D присваивается регистру A.   [A] = [D]
1#MOV A,E#-----#1#5#Значение регистра E присваивается регистру A.   [A] = [E]
1#MOV A,H#-----#1#5#Значение регистра H присваивается регистру A.   [A] = [H]
1#MOV A,L#-----#1#5#Значение регистра L присваивается регистру A.   [A] = [L]
1#MOV A,M#-----#1#7#Значение памяти по адресу пары регистров HL, присваивается регистру A.  [A] = M[H][L], M - память
1#MOV A,A#-----#1#5#Значение регистра A присваивается регистру A.   [A] = [A]
2#ADD B#+++++#1#4#Добавляет значение регистра B регистру A. [A] = [A] + [B]
2#ADD C#+++++#1#4#Добавляет значение регистра C регистру A. [A] = [A] + [C]
2#ADD D#+++++#1#4#Добавляет значение регистра D регистру A. [A] = [A] + [D]
2#ADD E#+++++#1#4#Добавляет значение регистра E регистру A. [A] = [A] + [E]
2#ADD H#+++++#1#4#Добавляет значение регистра H регистру A. [A] = [A] + [H]
2#ADD L#+++++#1#4#Добавляет значение регистра L регистру A. [A] = [A] + [L]
2#ADD M#+++++#1#7#Добавляет значение памяти по адресу пары регистров HL регистру A. [A] = [A] + M[H][L], M - память
2#ADD A#+++++#1#4#Добавляет значение регистра A регистру A. [A] = [A] + [A]
2#ADC B#+++++#1#4#Добавляет значение регистра B и флаг переноса к регистру A. [A] = [A] + [B] + [Carry]
2#ADC C#+++++#1#4#Добавляет значение регистра C и флаг переноса к регистру A. [A] = [A] + [C] + [Carry]
2#ADC D#+++++#1#4#Добавляет значение регистра D и флаг переноса к регистру A. [A] = [A] + [D] + [Carry]
2#ADC E#+++++#1#4#Добавляет значение регистра E и флаг переноса к регистру A. [A] = [A] + [E] + [Carry]
2#ADC H#+++++#1#4#Добавляет значение регистра H и флаг переноса к регистру A. [A] = [A] + [H] + [Carry]
2#ADC L#+++++#1#4#Добавляет значение регистра L и флаг переноса к регистру A. [A] = [A] + [L] + [Carry]
2#ADC M#+++++#1#7#Добавляет значение памяти по адресу пары регистров HL и флаг переноса к регистру A. [A] = [A] + M[H][L] + [Carry], M - память
2#ADC A#+++++#1#4#Добавляет значение регистра A and the carry flag to A. [A] = [A] + [A] + [Carry]
2#SUB B#+++++#1#4#Вычитает значение регистра B из регистра A. [A] = [A] - [B]
2#SUB C#+++++#1#4#Вычитает значение регистра C из регистра A. [A] = [A] - [C]
2#SUB D#+++++#1#4#Вычитает значение регистра D из регистра A. [A] = [A] - [D]
2#SUB E#+++++#1#4#Вычитает значение регистра E из регистра A. [A] = [A] - [E]
2#SUB H#+++++#1#4#Вычитает значение регистра H из регистра A. [A] = [A] - [H]
2#SUB L#+++++#1#4#Вычитает значение регистра L из регистра A. [A] = [A] - [L]
2#SUB M#+++++#1#7#Вычитает значение памяти по адресу пары регистров HL из регистра A. [A] = [A] - M[H][L]
2#SUB A#+++++#1#4#Вычитает значение регистра A из регистра A. [A] = [A] - [A]
2#SBB B#+++++#1#4#Вычитает значение регистра B и флаг переноса из регистра A. [A] = [A] - [B] - [Carry]
2#SBB C#+++++#1#4#Вычитает значение регистра С и флаг переноса из регистра A. [A] = [A] - [C] - [Carry]
2#SBB D#+++++#1#4#Вычитает значение регистра D и флаг переноса из регистра A. [A] = [A] - [D] - [Carry]
2#SBB E#+++++#1#4#Вычитает значение регистра E и флаг переноса из регистра A. [A] = [A] - [E] - [Carry]
2#SBB H#+++++#1#4#Вычитает значение регистра H и флаг переноса из регистра A. [A] = [A] - [H] - [Carry]
2#SBB L#+++++#1#4#Вычитает значение регистра L и флаг переноса из регистра A. [A] = [A] - [L] - [Carry]
2#SBB M#+++++#1#7#Вычитает значение памяти по адресу пары регистров HL и флаг переноса из регистра A. [A] = [A] - M[H][L] - [Carry], M - память
2#SBB A#+++++#1#4#Вычитает значение регистра A и флаг переноса из регистра A. [A] = [A] - [A] - [Carry]
2#ANA B#++++0#1#4#Побитовое И(AND) между регистрами А и B. [A] = [A] & [B]
2#ANA C#++++0#1#4#Побитовое И(AND) между регистрами A и C. [A] = [A] & [C]
2#ANA D#++++0#1#4#Побитовое И(AND) между регистрами A и D. [A] = [A] & [D]
2#ANA E#++++0#1#4#Побитовое И(AND) между регистрами A и E. [A] = [A] & [E]
2#ANA H#++++0#1#4#Побитовое И(AND) между регистрами A и H. [A] = [A] & [H]
2#ANA L#++++0#1#4#Побитовое И(AND) между регистрами A и L. [A] = [A] & [L] 
2#ANA M#++++0#1#7#Побитовое И(AND) между регистрами A и значением памяти по адресу пары регистров HL. [A] = [A] & M[H][L], M - память
2#ANA A#++++0#1#4#Побитовое И(AND) между регистрами A и A. [A] = [A] & [A]
2#XRA B#++0+0#1#4#Исключающее ИЛИ(XOR) между регистрами A и B. [A] = (![A] & [B]) | ([A] & ![B])
2#XRA C#++0+0#1#4#Исключающее ИЛИ(XOR) между регистрами A и C. [A] = (![A] & [C]) | ([A] & ![C])
2#XRA D#++0+0#1#4#Исключающее ИЛИ(XOR) между регистрами A и D. [A] = (![A] & [D]) | ([A] & ![D])
2#XRA E#++0+0#1#4#Исключающее ИЛИ(XOR) между регистрами A и E. [A] = (![A] & [E]) | ([A] & ![E])
2#XRA H#++0+0#1#4#Исключающее ИЛИ(XOR) между регистрами A и H. [A] = (![A] & [H]) | ([A] & ![H])
2#XRA L#++0+0#1#4#Исключающее ИЛИ(XOR) между регистрами A и L. [A] = (![A] & [L]) | ([A] & ![L])
2#XRA M#++0+0#1#7#Исключающее ИЛИ(XOR) между регистрами A и значением памяти по адресу пары регистров HL. [A] = (![A] & M[H][L] ) | ([A] & !M[H][L]), M - память
2#XRA A#++0+0#1#4#Исключающее ИЛИ(XOR) между регистрами A и A. [A] = (![A] & [A]) | ([A] & ![A])
2#ORA B#++0+0#1#4#Побитовое ИЛИ(OR) между регистрами A и B. [A] = [A] | [B]
2#ORA C#++0+0#1#4#Побитовое ИЛИ(OR) между регистрами А и C. [A] = [A] | [C]
2#ORA D#++0+0#1#4#Побитовое ИЛИ(OR) между регистрами A и D. [A] = [A] | [D]
2#ORA E#++0+0#1#4#Побитовое ИЛИ(OR) между регистрами A и E. [A] = [A] | [E]
2#ORA H#++0+0#1#4#Побитовое ИЛИ(OR) между регистрами A и H. [A] = [A] | [H]
2#ORA L#++0+0#1#4#Побитовое ИЛИ(OR) между регистрами A и L. [A] = [A] | [L]
2#ORA M#++0+0#1#7#Побитовое ИЛИ(OR) между регистрами A и значением памяти по адресу пары регистров HL. [A] = [A] | M[H][L], M - память
2#ORA A#++0+0#1#4#Побитовое ИЛИ(OR) между регистрами A и A. [A] = [A] | [A]
2#CMP B#+++++#1#4#Вычитает значение регистра B из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
2#CMP C#+++++#1#4#Вычитает значение регистра C из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
2#CMP D#+++++#1#4#Вычитает значение регистра D из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
2#CMP E#+++++#1#4#Вычитает значение регистра E из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
2#CMP H#+++++#1#4#Вычитает значение регистра H из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
2#CMP L#+++++#1#4#Вычитает значение регистра L из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
2#CMP M#+++++#1#7#Вычитает значение памяти по адресу пары регистров HL из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
2#CMP A#+++++#1#4#Вычитает значение регистра A из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
5#RNZ#-----#1#11/5#Если состояние флага (Zero = 0) это тождество, то два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
3#POP B#-----#1#10#Значение памяти хранящееся по адресу SP загружается в регистр C. SP увеличивается на единицу. Значение памяти хранящееся по адресу SP загружается в регистр B. SP вновь увеличивается на единицу.
5#JNZ b16#-----#3#10#Если состояние флага (Zero = 0) это тождество, тогда адрес (b16) загружается в PC.
5#JMP b16#-----#3#10#Aдрес (b16) загружается в PC.
5#CNZ b16#-----#3#17/11#Если состояние флага (Zero = 0) это тождество, тогда два байта адреса (PC + 3,следующей команды после CNZ), добавляются в стэк, а адрес (b16) загружается в PC.SP Увеличивается на два.
3#PUSH B#-----#1#11#SP уменьшается на единицу и значение памяти по адресу SP загружается в регистр B. SP уменьшается вновь на единицу и значение памяти по адресу SP загружается в регистр C.
2#ADI b8#+++++#2#7#Добавляет значение (b8) к регистру A. [A] = [A] + (b8)	
5#RST 0#-----#1#11#Два байта текущего адреса (PC + 1,следующей команды после RST 0), добавляются в стэк, а адрес 0x0000 загружается в PC. Эквивалентно (CALL 0x0000)
5#RZ#-----#1#11/5#Если состояние флага (Zero = 1) это тождество, то два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
5#RET#-----#1#10#Два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
5#JZ b16#-----#3#10#Если состояние флага (Zero = 1) это тождество, тогда адрес (b16) загружается в PC.
4
5#CZ b16#-----#3#17/11#Если состояние флага (Zero = 1) это тождество, тогда два байта адреса (PC + 3,следующей команды после CZ), добавляются в стэк, а адрес (b16) загружается в PC. SP Увеличивается на два.
5#CALL b16#-----#3#17#Два байта адреса (PC + 3,следующей команды после CALL), добавляются в стэк, а адрес (b16) загружается в PC.
2#ACI b8#+++++#2#7#Добавляет значение (b8) и состояние флага [Carry] к регистру A. [A] = [A] + (b8) + [Carry]
5#RST 1#-----#1#11#Два байта текущего адреса (PC + 1,следующей команды после RST 1), добавляются в стэк, а адрес 0x0008 загружается в PC. Эквивалентно (CALL 0x0008)
5#RNC#-----#1#11/5#Если состояние флага (Carry = 0) это тождество, то два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
3#POP D#-----#1#10#Значение памяти хранящееся по адресу SP загружается в регистр E. SP увеличивается на единицу. Значение памяти хранящееся по адресу SP загружается в регистр D. SP вновь увеличивается на единицу.
5#JNC b16#-----#3#10#Если состояние флага (Carry = 0) это тождество, тогда адрес (b16) загружается в PC.
1#OUT b8#-----#2#10#Значение регистра A записывается в порт по адресу (b8).
5#CNC b16#-----#3#17/11#Если состояние флага (Carry = 0) это тождество, тогда два байта адреса (PC + 3,следующей команды после CNC), добавляются в стэк, а адрес (b16) загружается в PC. SP Увеличивается на два.
3#PUSH D#-----#1#11#SP уменьшается на единицу и значение памяти по адресу SP загружается в регистр D. SP уменьшается вновь на единицу и значение памяти по адресу SP загружается в регистр E.
2#SUI b8#+++++#2#7#Вычитает значение (b8) из регистра A. [A] = [A] - (b8)
5#RST 2#-----#1#11#Два байта текущего адреса (PC + 1,следующей команды после RST 2), добавляются в стэк, а адрес 0x0010 загружается в PC. Эквивалентно (CALL 0x0010)
5#RC#-----#1#11/5#Если состояние флага (Carry = 1) это тождество, то два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
4
5#JC b16#-----#3#10#Если состояние флага (Carry = 1) это тождество, тогда адрес (b16) загружается в PC.
1#IN b8#-----#2#10#Из порта по адресу (b8) загружается значение в регистр А.
5#CC b16#-----#3#17/11#Если состояние флага (Carry = 1) это тождество, тогда два байта адреса (PC + 3,следующей команды после CC), добавляются в стэк, а адрес (b16) загружается в PC.
4
2#SBI b8#+++++#2#7#Вычитает значение (b8) и состояние флага [Carry] из регистра A. [A] = [A] - (b8) - [Carry]
5#RST 3#-----#1#11#Два байта текущего адреса (PC + 1,следующей команды после RST 3), добавляются в стэк, а адрес 0x0018 загружается в PC. Эквивалентно (CALL 0x0018)
5#RPO#-----#1#11/5#Если состояние флага (Paruty = 0) это тождество, то два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
3#POP H#-----#1#10#Значение памяти хранящееся по адресу SP загружается в регистр L. SP увеличивается на единицу. Значение памяти хранящееся по адресу SP загружается в регистр H. SP вновь увеличивается на единицу.
5#JPO b16#-----#3#10#Если состояние флага (Paruty = 0) это тождество, тогда адрес (b16) загружается в PC.
3#XTHL#-----#1#18#Меняет местами значение памяти по адресу SP c значением регистра L, и также с адресом памяти (SP + 1) и регистром H. Память поменяется, а значение SP не поменяется.
5#CPO b16#-----#3#17/11#Если состояние флага (Paruty = 0) это тождество, тогда два байта адреса (PC + 3,следующей команды после CPO), добавляются в стэк, а адрес (b16) загружается в PC. SP Увеличивается на два.
3#PUSH H#-----#1#11#SP уменьшается на единицу и значение памяти по адресу SP загружается в регистр H. SP уменьшается вновь на единицу и значение памяти по адресу SP загружается в регистр L.
2#ANI b8#++++0#2#7#Побитовое И(AND) между регистром A и значеним (b8). [A] = [A] & (b8)
5#RST 4#-----#1#11#Два байта текущего адреса (PC + 1,следующей команды после RST 4), добавляются в стэк, а адрес 0x0020 загружается в PC. Эквивалентно (CALL 0x0020)
5#RPE#-----#1#11/5#Если состояние флага (Paruty = 1) это тождество, то два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
5#PCHL#-----#1#5#Загружает значение пар регистров HL в адрес текущей позиции процессора PC.
5#JPE b16#-----#3#10#Если состояние флага (Paruty = 1) это тождество, тогда адрес (b16) загружается в PC.
1#XCHG#-----#1#4#Меняет местами значения двухбайтовых чисел пар регистров BC и DE.
5#CPE b16#-----#3#17/11#Если состояние флага (Paruty = 1) это тождество, тогда два байта адреса (PC + 3,следующей команды после CPE), добавляются в стэк, а адрес (b16) загружается в PC. SP Увеличивается на два.
4
2#XRI b8#++0+0#2#7#Побитовое Иcключающее ИЛИ(XOR) между регистром A и значеним (b8). [A] = (![A] & (b8)) | ([A] & !(b8))
5#RST 5#-----#1#11#Два байта текущего адреса (PC + 1,следующей команды после RST 5), добавляются в стэк, а адрес 0x0028 загружается в PC. Эквивалентно (CALL 0x0028)
5#RP#-----#1#11/5#Если состояние флага (Sign = 0) это тождество, то два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
3#POP PSW#-----#1#10#Значение памяти хранящееся по адресу SP загружается в регистр PSW. SP увеличивается на единицу. Значение памяти хранящееся по адресу SP загружается в регистр A. SP вновь увеличивается на единицу.
5#JP b16#-----#3#10#Если состояние флага (Sign = 0) это тождество, тогда адрес (b16) загружается в PC.
4
5#CP b16#-----#3#17/11#Если состояние флага (Sign = 0) это тождество, тогда два байта адреса (PC + 3,следующей команды после CP), добавляются в стэк, а адрес (b16) загружается в PC. SP Увеличивается на два.
3#PUSH PSW#-----#1#11#SP уменьшается на единицу и значение памяти по адресу SP загружается в регистр A. SP уменьшается вновь на единицу и значение памяти по адресу SP загружается в регистр PSW.
2#ORI b8#++0+0#2#7#Побитовое ИЛИ(OR) между регистром A и значеним (b8). [A] = [A] | (b8)
5#RST 6#-----#1#11#Два байта текущего адреса (PC + 1,следующей команды после RST 6), добавляются в стэк, а адрес 0x0030 загружается в PC. Эквивалентно (CALL 0x0030)
5#RM#-----#1#11/5#Если состояние флага (Sign = 1) это тождество, то два байта верхушки SP заносятся в PC. При этом SP уменьшается на два.
3#SPHL#-----#1#5#Загружает значение двух байтвого числа пары регистров HL в стэк SP. При этом SP увеличится на два.
5#JM b16#-----#3#10#Если состояние флага (Sign = 1) это тождество, тогда адрес (b16) загружается в PC.
4
5#CM b16#-----#3#17/11#Если состояние флага (Sign = 1) это тождество, тогда два байта адреса (PC + 3,следующей команды после CM), добавляются в стэк, а адрес (b16) загружается в PC. SP Увеличивается на два.
4
2#CPI b8#+++++#2#7#Вычитает значение (b8) из регистра A и меняет состояние флагов в зависимости от результат. При этом регистр А не меняется.
5#RST 7#-----#1#11#Два байта текущего адреса (PC + 1,следующей команды после RST 7), добавляются в стэк, а адрес 0x0038 загружается в PC. Эквивалентно (CALL 0x0038)