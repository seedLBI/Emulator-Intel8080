[ABBRIV_MEAN] [A] [8-разрядный регистр, аккумулятор]
[ABBRIV_MEAN] [B] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [C] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [D] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [E] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [H] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [L] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [M] [Значение памяти по адресу <H> и <L>. Индекс вычисляется так: Memory<H*256 + L>]
[ABBRIV_MEAN] [F] [регистр флагов]

[ABBRIV_MEAN] [PC] [счётчик команд, содержит адрес очередной исполняемой команды]
[ABBRIV_MEAN] [SP] [указатель стека]

[ABBRIV_MEAN] [BC] [регистровая пара (B - старший регистр, C - младший)]
[ABBRIV_MEAN] [DE] [регистровая пара (D - старший регистр, E - младший)]
[ABBRIV_MEAN] [HL] [регистровая пара (H - старший регистр, L - младший)]
[ABBRIV_MEAN] [PSW] [регистровая пара (A - аккумулятор старший регистр, F - младший регистр флагов)]

[ABBRIV_MEAN] [Carry] [флаг переноса (реагирует на переполнение регистра A)]
[ABBRIV_MEAN] [Zero] [равенство результата операции нулю]
[ABBRIV_MEAN] [Sign] [знак операции (реагирует на последний 8-ой бит регистра А)]
[ABBRIV_MEAN] [Paruty] [паритет (чётность количества единиц в регистре A)]

[ABBRIV_MEAN] [r] [регистры (A, B, C, D, E, H, L, M)]
[ABBRIV_MEAN] [rp] [пары регистров (B == BC, D == DE, H == HL)]
[ABBRIV_MEAN] [b8] [(8 бит) значение (0x00 - 0xFF)(0 - 256)(название константы)]
[ABBRIV_MEAN] [b16] [(16 бит) значение (0x0000 - 0xFFFF)(0 - 65536)(название константы, маркера)]
[ABBRIV_MEAN] [adr] [(название маркера, константы, или полноценный адрес 0x0000 - 0xFFFF)]

[ABBRIV_MEAN] [.adr:] [Деректива транслятора, отвечающая за установку начала адресов последующих команд]
[ABBRIV_MEAN] [.set:] [Деректива транслятора, отвечающая за установку байта данных на текущий адрес]
[ABBRIV_MEAN] [.const:] [Деректива транслятора, отвечающая за добавление в список постоянных, постоянной...]

[ABBRIV_MEAN] [Асинхронный] [Выполняется без остановок процессора]
[ABBRIV_MEAN] [Cинхронный] [Выполняется с остановками процессора, дожидаясь действий со стороны пользовтеля]


[ABBRIV_MEAN] [ЛКМ] [Левая кнопка мыши]
[ABBRIV_MEAN] [ПКМ] [Правая кнопка мыши]
[ABBRIV_MEAN] [СКМ] [Средняя кнопка мыши (колёсико)]




[BEGIN_CATEGORY] [Регистры]
<A>  - 8-разрядный регистр, аккумулятор. Все арифметические и логические операции 
производятся только между регистром <A> и другими регистрами или между регистром <A>
и байтом непосредственных данных.
<B> - 8-разрядный регистр общего назначения. Старший регистр регистровой пары <BC>.
<C> - 8-разрядный регистр общего назначения. Младший регистр регистровой пары <BC>.
<D> - 8-разрядный регистр общего назначения. Старший регистр регистровой пары <DE>.
<E> - 8-разрядный регистр общего назначения. Младший регистр регистровой пары <DE>.
<H> - 8-разрядный регистр общего назначения. Старший регистр регистровой пары <HL>.
<L> - 8-разрядный регистр общего назначения. Младший регистр регистровой пары <HL>.
<M> - Значение памяти по адресу <H> и <L>. Индекс вычисляется так: Memory[<H> * 256 + <L>].
<PC> - счётчик команд, содержит адрес очередной исполняемой команды.	
<SP> - указатель стека. Указатель стека автоматически декрементируется на 2 при 
записи пары регистров в стек (отдельный 8-разрядный регистр в стек записать 
нельзя, только парами) и инкрементируется при извлечении регистровой пары из стека.
<F> - регистр флагов. Непосредственно недоступен программисту, но его в составе 
регистровой пары <PSW> можно сохранить в стеке, а потом извлечь в другую регистровую 
пару, если нужно специально установить или проверить нужные флаги.
[END]

[BEGIN_CATEGORY] [Регистровые пары]
<BC> - регистровая пара, состоящая из двух 8-разрядных регистров (<B> - старший регистр, <C> - младший).
<DE> - регистровая пара, состоящая из двух 8-разрядных регистров (<D> - старший регистр, <E> - младший).
<HL> - регистровая пара, состоящая из двух 8-разрядных регистров (<H> - старший регистр, <L> - младший), используется для косвенно-регистровой адресации 64 Кбайт памяти.
<PSW> - регистровая пара, состоящая из двух 8-разрядных регистров (<A> (аккумулятор) - старший регистр, <F> (регистр флагов) - младший).
[END]

[BEGIN_CATEGORY] [Флаги]
<Carry>  - флаг переноса (реагирует на переполнение регистра <A> ).
<Zero>   - равенство результата операции нулю.
<Sign>   - знак операции (реагирует на последний 8-ой бит регистра <A> ).
<Paruty> - паритет ( чётность количества единиц в регистре <A> ).
[END]

[BEGIN_CATEGORY] [Обозначения]
(<r>)  - регистры (<A>, <B>, <C>, <D>, <E>, <H>, <L>, <M>)
(<rp>) - пары регистров (<B> == <BC>, <D> == <DE>, <H> == <HL>)
(<b8>) - (8 бит) значение (0x00 - 0xFF)(0 - 256)(название константы)
(<b16>)- (16 бит) значение (0x0000 - 0xFFFF)(0 - 65536)(название константы)
(<adr>)- (название маркера, константы, или полноценный адрес 0x0000 - 0xFFFF) 
[END]



[BEGIN_CATEGORY] [Команды]
[BEGIN] [Команды пересылки данных]
#mov#  (<r>, <r>) - пересылка данных между регистрами общего назначения или между регистром и ячейкой памяти.
#mvi#  (<r>, <b8>) - загрузка константного значения (байта) в регистр общего назначения.
#lxi#  (<rp>, <b16>) - загрузка константного значения (двойного байта) в регистровую пару.
#lda#  (<b16>) - прямая загрузка значения ячейки памяти в аккумулятор.
#lhld# (<b16>) - прямая загрузка значений ячеек памяти в пару регистров <HL>.
#sta#  (<b16>) - прямая запись содержимого регистра <A> в ячеку памяти.
#shld# (<b16>) - прямая запись содержимого пары регистров <HL> в ячейку памяти.
#ldax# (<BC> или <DE>) - косвенная загрузка содержимого ячейки памяти в регистр <A> через адрес, хранящийся в <BC> или <DE>.
#stax# (<BC> или <DE>) - косвенная запись содержимого регистра <A> в ячейку памяти через адрес, хранящийся в <BC> или <DE>.
#xchg# - обмен значениями между парами регистров <HL> и <DE>.
[END]

[BEGIN] [Суммирование и инкременты]
#add# (<r>) - сложение [<A> = <A> + <r>].
#adi# (<b8>) - сложение с константой [<A> = <A> + <b8>].
#adc# (<r>) - сложение с учётом переноса [<A> = <A> + <r> + <Carry>].
#aci# (<b8>) - сложение с константой с учётом переноса [<A> = <A> + <b8> + <Carry>].
#inr# (<r>) - инкремент [<r> = <r> + 1].
#inx# (<rp>) - инкремент пары регистров [<rp> = <rp> + 1].
#dad# (<rp>) - сложение пары регистров [<HL> = <HL> + <rp>]. 
[END]

[BEGIN] [Вычитание и декременты]
#sub# (<r>) - вычитание [<A> = <A> - <r>].
#sui# (<b8>) - вычитание константы [<A> = <A> - <b8>].
#sbb# (<r>) - вычитание с учётом переноса [<A> = <A> - <r> - <Carry>].
#sbi# (<b8>) - вычитание константы с учётом переноса [<A> = <A> - <b8> - <Carry>].
#dcr# (<r>) - декремент [<r> = <r> - 1]. 
#dcx# (<rp>) - декремент пары регистров [<rp> = <rp> - 1].
[END]

[BEGIN] [Логические]
#ana# (<r>) - логическое И [<A> = <A> & <r>].
#ani# (<b8>) - логическое И с константой [<A> = <A> & <b8>].
#ora# (<r>) - логическое ИЛИ [<A> = <A> | <r>].
#ori# (<b8>) - логическое ИЛИ с константой.
#xra# (<r>) - исключающее ИЛИ [<A> = <A> ^ <r>].
#xri# (<b8>) - исключающее ИЛИ с константой [<A> = <A> ^ <b8>].
#rlc# - циклический сдвиг аккумулятора влево.
#rrc# - циклический сдвиг аккумулятора вправо.
#ral# - арифметический сдвиг влево через перенос.
#rar# - арифметический сдвиг вправо через перенос.
#cma# - инвертирование содержимого регистра <A> [<A> = !<A>].
#stc# - установка флага переноса (<Carry>) в 1.
#cmc# - инвертирование флага переноса (<Carry>).
[END]

[BEGIN] [Сравнения]
#cmp# (<r>) - сравнение с регистром.
#cpi# (<b8>) - сравнение с константой.
[END]

[BEGIN] [Вызовы подпрограммы]
#call#(<adr>) - вызов подпрограммы по адресу.
#cnz# (<adr>) - вызов подпрограммы по адресу, если <Zero> = 0.
#cz#  (<adr>) - вызов подпрограммы по адресу, если <Zero> = 1.
#cnc# (<adr>) - вызов подпрограммы по адресу, если <Carry> = 0.
#cc#  (<adr>) - вызов подпрограммы по адресу, если <Carry> = 1.
#cpo# (<adr>) - вызов подпрограммы по адресу, если <Paruty> = 0.
#cpe# (<adr>) - вызов подпрограммы по адресу, если <Paruty> = 1.
#cp#  (<adr>) - вызов подпрограммы по адресу, если <Sign> = 0.
#cm#  (<adr>) - вызов подпрограммы по адресу, если <Sign> = 1.
[END]

[BEGIN] [Возвраты из подпрограммы]
#ret# - возврат из подпрограммы.
#rnz# - возврат из подпрограммы, если <Zero> = 0.
#rz#  - возврат из подпрограммы, если <Zero> = 1
#rnc# - возврат из подпрограммы, если <Carry> = 0.
#rc#  - возврат из подпрограммы, если <Carry> = 1.
#rpo# - возврат из подпрограммы, если <Paruty> = 0.
#rpe# - возврат из подпрограммы, если <Paruty> = 1.
#rp#  - возврат из подпрограммы, если <Sign> = 0.
#rm#  - возврат из подпрограммы, если <Sign> = 1.
[END]

[BEGIN] [Переходы (прыжки)]
#jmp# (<adr>) - безусловный переход.
#jz#  (<adr>) - переход, если <Zero> = 1.
#jnz# (<adr>) - переход, если <Zero> = 0.
#jc#  (<adr>) - переход, если <Carry> = 1.
#jnc# (<adr>) - переход, если <Carry> = 0.
#jp#  (<adr>) - переход, если <Sign> = 0.
#jm#  (<adr>) - переход, если <Sign> = 1.
#jpo# (<adr>) - переход, если <Paruty> = 0.
#jpe# (<adr>) - переход, если <Paruty> = 1.
[END]


[BEGIN] [Управления вводом/выводом]
#in# (<b8>) - чтение значения из порта в аккумулятор <A>.
#out#(<b8>) - запись значения из аккумулятора <A> в порт.
[END]

[BEGIN] [Работа со стеком и не только]
#pchl# - переход по адресу из пары регистров <HL>.
#sphl# - загрузка содержимого из пары регистров <HL> в указатель стека (<SP>)
#push# (<rp>) - загрузка содержимого пары регистров (<BC>, <DE>, <HL>, <PSW>) в стек.
#pop#  (<rp>) - загрузка содержимого из вершины стека в пару регистров (<BC>, <DE>, <HL>, <PSW>).
#xthl# - обмен между вершиной стека и парой регистров <HL>.
#nop#  - нет операции.
#hlt#  - остановка процессора.
[END]
[END]




[BEGIN_CATEGORY] [Метки\Маркеры]
[BEGIN] [Глобальные]
Маркеры или же метки (пример "Main: ") - это один из способов задания адреса, но в отличии от абсолютного адреса (пример: 0x00FA), адрес маркера определяется на этапе трансляции кода.

Примечание: маркеры чуствительны к регистру ("Main" != "MAIN"). метка без точки в начале называется "глобальной меткой"

[BEGIN_CODE] [Пример "глобальных" меток]
Main:
	mvi A,16
Loop:
	dcr A
	jz End
	jmp Loop
End:
	hlt
[END_CODE]

[END]

[BEGIN] [Локальные]
Локальная метка - это метка имя которой начинается с точки. Во время трансляции кода к началу имён локальных меток добавляется имя последней "глобальной" метки. Таким образом, имена локальных меток могут повторяться, если между ними есть хотя бы одна "глобальная" метка.

[BEGIN_CODE] [Пример "локальных" меток]
Main:
	call Cycle_16
	call Cycle_32
	mvi a, 10
	call Cycle_16.loop ; Так же можно задать
					   ; локальный адрес напрямую
	hlt

Cycle_16:
	mvi A,16
	.loop:		; .loop: = Cycle_16.loop:
		dcr A
		jz .end
		jmp .loop
	.end:		; .end: = Cycle_16.end:
		ret

Cycle_32:
	mvi A,32
	.loop:		; .loop: = Cycle_32.loop:
		dcr A
		jz .end
		jmp .loop
	.end:		; .end: = Cycle_32.end:
		ret
[END_CODE]
[END]
[END]




[BEGIN_CATEGORY] [Дерективы транслятора]

[BEGIN] [.adr:]
<.adr:> value - директива установки адреса (2 байта). Команды и данные, следующие за этой директивой будут загружены в память начиная с указанного в директиве адреса.

Пример, как при помощи .adr будут распологаться байты в памяти после компиляции:

[BEGIN_CODE] [Пример]
.adr: 0x0010

mvi A, 0xFF  ;0x0010 0x0011
mvi B, 0xCC  ;0x0012 0x0013
cpi B        ;0x0014
hlt          ;0x0015
[END_CODE]
[END]



[BEGIN] [.set:]
<.set:> value - директива загрузки в ячейку памяти микропроцессора значения (байта). Используется для формирования в памяти массива данных.

Значение могут быть введены в следующих форматах

[BEGIN_CODE] [Возможные форматы]
.set: 0b00001010 ; двоичный
.set: 123        ; десятичный
.set: 0x15       ; шестнадцитиричный
.set: "a"        ; символный (каждый символ переводится в значение таблицы ASCII 1251)
[END_CODE]

Также можно перечеслять в одну строку несколько значений

[BEGIN_CODE] [Примеры]
.set: 0x01, 0x02, 0x10, 0xff
.set: "Можно ввести целую строку! ", "о", "дааа"
.set: 0b00101, "можно комбинировать", 228, 0xf1
[END_CODE]

[END]



[BEGIN] [.const:]
<.const:> const_name value - деректива создания макроса\константы которое преобразуется в соответсвующее ей число(1 или 2 байта) на этапе компиляции.

Пример:

[BEGIN_CODE] [Пример]
.const: port_screen 0x05
.const: mode_load 0x00

jmp Main

Main:
	mvi a, 0x0a
	out port_screen   ; = out 0x05
	mvi a, mode_load  ; = mvi a, 0x00
	out port_screen   ; = out 0x05
[END_CODE]
[END]

[END]









[BEGIN_CATEGORY] [Описание окон]

[BEGIN] [Редактор кода]
Реализует редактор кода с подсветкой синтаксиса для каждой категории команд (дерективы, комментарии, маркеры, разные инструкции).
Реализованы разные популярные комбинации клавиш для копирования, вставки, выделения.
Примечание: для подсветки синтаксиса инструкций, нельзя использовать заглавные буквы
При наведению на подсвеченную инструкцию выводится её краткая информация (описание работы, кол - во байт, типы аргументов).
[BEGIN_CODE][Пример]
MVI a,10 ; эта строчка не будет подсвечиваться
mvi a,10 ; а вот эта будет.
[END_CODE]


[END]

[BEGIN] [Просмотр мнемо кода]
Реализует вывод памяти процессора в формате мнемокодов, значения или адреса. которых были взяты из редактора кода, что может быть удобно при навегации по памяти..
[END]

[BEGIN] [Hex просмотр]
Реализует вывод памяти процессора в шестнадцетиричном формате.
Может взаимодействовать с процессом эмуляции при помощи мыши:
При нажатии на ячейку адреса памяти:
<ЛКМ> - Регистр PC изменится на соответствующий адрес
<ПКМ> - Добавит точку останова на соответствующий адрес.
[END]

[BEGIN] [Пиксельный экран]
Реализует вывод состояния внешнего устройства #Пиксельный экран#.
С помощью нажатия <ПКМ> можно открыть меню в котором можно настроить отображение.
[END]

[BEGIN] [Продвинутый пиксельный экран]
Реализует вывод состояния внешнего устройства #Продвинутый пиксельный экран#.
С помощью нажатия <ПКМ> можно открыть меню в котором можно настроить отображение.
[END]

[BEGIN] [Символьный экран]
Реализует вывод состояния внешнего устройства #Символьный экран#.
При наведении на любую ячейку экрана производится вывод её информации.
С помощью нажатия <ПКМ> можно открыть меню в котором можно настроить отображение.
[END]

[BEGIN] [Таймер]
Взаимодействует с внешним устройством (Таймер) и отображает его текущее значение.
[END]

[BEGIN] [Окно вывода]
Взаимодействует с внешним устройством #Окно вывода#. Отображает все полученные значение за сеанс эмуляции.
[END]

[BEGIN] [Окно ввода]
Взаимодействует с внешним устройством #Окно ввода# и реализует возможность ввода 8 битных значений.
[END]

[BEGIN] [Окно клавиатуры]
Отображает кнопки которые может считывать внешнее устройство #Клавиатура#.
[END]

[BEGIN] [Все цвета]
Отображает все возможные цвета для упрощённой модели RGB[0brrgggbbb].
Может взаимодействовать с окном {Редактор кода}, с помощью <ЛКМ> будет производится копирование значения выбранного цвета на позицию текущего курсора в редакторе.
[END]

[BEGIN] [Все символы]
Отображает все символы кодировки ASCII1251.
Может взаимодействовать с окном {Редактор кода}, с помощью <ЛКМ> будет производится копирование значения выбранного символа на позицию текущего курсора в редакторе.
[END]

[BEGIN] [Регистры и флаги]
Отображает состояния процессора на текущий момент времени.
[END]

[BEGIN] [Быстродействие]
Отображает различные метрики работы процессора
[END]

[BEGIN] [Список маркеров]
Отображает список маркеров, которые встретились при компиляции.
Может взаимодействовать с окном {Мнемо код} и самим процессором.
При нажатии на маркер:
<ЛКМ> - Регистр PC изменится на соответствующий адрес и слайдер наведётся на нужный адрес в окне #Мнемо код#
<ПКМ> - Добавит точку останова на соответствующий адрес.
<СКМ> - Слайдер наведётся на нужный адрес в окне #Мнемо код#
[END]

[BEGIN] [Список переменных]
Отображает список переменных, которые встретились при компиляции.
Переменной будет являться тот байт который установленн с помощью <.set:> который идёт сразу после маркера.

[BEGIN_CODE][Пример переменной]
.name_var: ; глобальный маркер
.set: 0    ; значение в памяти
[END_CODE]

Польза этого списка заключается в том, что значение переменных иземеняются в реальном времени вслед за эмуляцией, что может быть удобно при отладке программы.
[END]

[BEGIN] [Список постоянных]
Отображает список постоянных, которые встретились при компиляции.
Постоянные это те значение которые были созданы с помощью дерективы <.const:>
[END]

[END]










[BEGIN_CATEGORY] [Внешние устройства]


[BEGIN] [(0x02) Вывод в консоль]
#Порт:# 0x02
#Тип взаимодействия:# <Асинхронный>
#Окно для взаимодействия:# {Окно вывода}

Протокол обмена информацией:
Команда записи значения в порт 0x02 (OUT 0x02) осуществляет вывод значения в консоль.

[BEGIN_CODE] [Отправка значения в консоль]
mvi a, 228
out 0x02   ; Число 228 отобразиться в консоли
hlt
[END_CODE]
[END]


[BEGIN] [(0x08) Ввод с клавиатуры]
#Порт:# 0x08
#Тип взаимодействия:# <Cинхронный>
#Окно для взаимодействия:# {Окно ввода}

Протокол обмена информацией:
Команда чтения значения из порта 0x08 (IN 0x08) осуществляет запрос на ввод значения с клавиатуры. При этом выполнение следующей инструкции замороженно до тех пор пока пользователь не введёт значение.

[BEGIN_CODE] [Пример]
in 0x08 ; ждём ввода от пользователя
hlt		; введённое значение переместится в регистр А
[END_CODE]
[END]

[BEGIN] [(0x09) Генератор рандомных чисел]
#Порт:# 0x09
#Тип взаимодействия:# <Асинхронный>
#Максимальное значение:# 255

Протокол обмена информацией:
#1.# Записать в порт 0x09 диапазон генерации значение (от 0 до 255)
#2.# Прочитать сгенирированного значения

Для генерации нового числа, нужно произвести шаги протокола заново

[BEGIN_CODE] [Запись диапазона и чтение сгенирированного числа]
mvi A, 30   ; Диапозон для генератора
out 0x09    ; Запись диапазона в генератор
in 0x09     ; Чтение сгенирированного значения
hlt
[END_CODE]
[END]


[BEGIN] [(0x05) Пиксельный экран]
#Порт:# 0x05
#Тип взаимодействия:# <Асинхронный>
#Разрешение:# 256x256
#Кол-во цветов:# 256 (кодируются по упрощённой модели RGB[0bRRGGGBBB])
#Кол-во буферов:# 1
#Окно для взаимодействия:# {Пиксельный экран}
#Вспомогающее окно:# {Все цвета}

Протокол обмена информацией:

#1.# Записать в порт 0x05 номер строки пиксельного экрана (0 - 255).
#2.# Записать в порт 0x05 номер столбца пиксельного экрана (0 - 255).
#3.# Выбрать режим записи/чтения. (0x00 - запись, любое другое значение - чтение).
#4.# Записать/прочитать значение цвета выбранного пикселя экрана.

Пример установки пикселя с координатами [Row: 10, Column: 15] в синий цвет:

[BEGIN_CODE] [Установка]
mvi A, 0x0A       ; номер строки пикселя
out 0x05          ; запись номера строки
mvi A, 0x0F       ; номер столбца пикселя
out 0x05          ; запись номера столбца
mvi A, 0x00       ; загрузка нулевого значения в регистр (режим записи)
out 0x05          ; запись нулевого значения (установка режима записи)
mvi A, 0b11111111 ; загрузка значения цвета пикселя (цвет пикселя кодируется по упрощенной модели RGB: 0bRRGGGBBB)
out 0x05          ; запись значения цвета пикселя
hlt
[END_CODE]
Пример чтения значения пикселя с координатами [Row: 10, Column: 15]:

[BEGIN_CODE] [Чтение]
mvi A, 0x0A  ; номер строки пикселя
out 0x05     ; запись номера строки
mvi A, 0x0F  ; номер столбца пикселя
out 0x05     ; запись номера столбца
mvi A, 0xFF  ; загрузка значения отличного от нуля в регистр (режим чтения)
out 0x05     ; запись значения(установка режима чтения)
in 0x05      ; чтение значения пикселя
hlt
[END_CODE]
[END]








[BEGIN] [(0x06) Продвинутый пиксельный экран]
#Порт:# 0x06
#Тип взаимодействия:# <Асинхронный>
#Разрешение:# 256x256
#Кол-во буферов:# 2 (передний - который мы наблюдаем, задний - с которым взаимодействуем)
#Кол-во цветов:# 256 (кодируются по упрощённой модели RGB[0bRRGGGBBB])
#Окно для взаимодействия:# {Продвинутый пиксельный экран}
#Вспомогающее окно:# {Все цвета}

Протокол обмена информацией:
#1.# Записать в порт 0x06 режим (0 - 3) 0 - Установить пиксель, 1 - Прочитать пиксель, 2 - Поменять буферы, 3 - отчистить буферы. Если выбран режим (2) или (3) то начинать сначала
#2.# Записать в порт 0x06 номер строки  (0 - 255)
#3.# Записать в порт 0x06 номер столбца (0 - 255)
Если выбран режим (1) то вызываем in 0x06 и получаем значение пикселя
#4.# Записать в порт 0x06 цвет (в формате 0bRRGGGBBB)


[BEGIN_CODE] [Установка цвета пикселя во второй буфер]
mvi A, 0           ; Режим - установка цвета пикселя
out 0x06           ; Отправляем выбранный режим
mvi A, 0x0F        ; номер строки пикселя  (Y)
out 0x06           ; запись номера строки
mvi A, 0x0F        ; номер столбца пикселя (X)
out 0x06           ; запись номера столбца
mvi A, 0b11111111  ; Белый цвет (Red - 11, Green - 111, Blue - 111)
out 0x06           ; Устанавливаем цвет
hlt
[END_CODE]
Чтобы мы увидели изменение нужно поменять данные для переднего и заднего буфера местами

[BEGIN_CODE] [Смена буферов]
mvi A, 2           ; Режим - Смена буферов
out 0x06           ; Отправляем выбранный режим
hlt
[END_CODE]

[BEGIN_CODE] [Полная отчистка буферов]
mvi A, 3           ; Режим - Отчиска буферов
out 0x06           ; Отправляем выбранный режим
hlt
[END_CODE]

[BEGIN_CODE] [Чтение значение цвета пикселя из второго буфер]
mvi A, 1           ; Режим - чтение цвета пикселя
out 0x06           ; Отправляем выбранный режим
mvi A, 0x0F        ; номер строки пикселя  (Y)
out 0x06           ; запись номера строки
mvi A, 0x0F        ; номер столбца пикселя (X)
out 0x06           ; запись номера столбца
in 0x06            ; Получаем значение пикселя в регистр А
hlt
[END_CODE]
[END]



[BEGIN] [(0x07) Символьный экран]
#Порт:# 0x07
#Тип взаимодействия:# <Асинхронный>
#Разрешение:# 20x20
#Кол-во буферов:# 1 
#Кол-во цветов фона:# 8 (кодируются по упрощённой модели RGB[0bxxRGBxxx])
#Кол-во цветов текста:# 8 (кодируются по упрощённой модели RGB[0bxxxxxRGB])
#Кодировка символов:# ASCII 1251
#Окно для взаимодействия:# {Символьный экран}
#Вспомогающее окно:# {Все символы}

Протокол обмена информацией:

#1.# Записать в порт 0x07 номер строки символьного экрана (0 - 19).
#2.# Записать в порт 0x07 номер столбца символьного экрана (0 - 19).
#3.# Выбрать режим записи/чтения. (0x00 - запись, любое другое значение - чтение).
#4.# Записать/прочитать значение цвета фона и цвета символа выбранного пикселя экрана (цвет фона кодируется по упрощенной модели RGB. Пятым, четвёртым и третьим битами: 0bxxRGBxxx; цвет символа кодируется по упрощенной модели RGB вторым, первым и нулевым битами: (0bxxxxxRGB). Цвет фона и цвет пикселя передаются одним байтом.
#5.# Записать/прочитать значение кода символа выбранного пикселя экрана (Код символа таблицы ASCII 1251).

Пример вывода на экран символа '$' в зелёном цвете на синем фоне в пикселе с координатами [Row: 1, Column: 3]:

[BEGIN_CODE] [Запись цвета и символа]
mvi A, 0x01        ; номер строки пикселя
out 0x07           ; запись номера строки
mvi A, 0x03        ; номер столбца пикселя
out 0x07           ; запись номера столбца
mvi A, 0x00        ; загрузка нулевого значения в регистр (режим записи)
out 0x07           ; установка режима записи
mvi A, 0b00001010  ; загрузка кода цвета фона (0bxx001xxx - синий) и цвета символа (0bxxxxx010 - зелёный).
out 0x07           ; запись значения цвета фона и цвета символа
mvi A, 0x24        ; загрузка кода символа '$' согласно таблицы ASCII 1251
out 0x07           ; запись значения кода символа
hlt
[END_CODE]

[BEGIN_CODE] [Чтение значения символа и его цвета]
mvi A, 0x01        ; номер строки пикселя
out 0x07           ; запись номера строки
mvi A, 0x03        ; номер столбца пикселя
out 0x07           ; запись номера столбца
mvi A, 0x01        ; загрузка ненулевого значения в регистр (режим записи)
out 0x07           ; установка режима чтения
in 0x07 		   ; Значение цвета передаётся в регистр А
in 0x07 		   ; Значение символа передаётся в регистр А
hlt
[END_CODE]
[END]


[BEGIN] [(0x16) Таймер]
#Порт:# 0x16
#Тип взаимодействия:# <Асинхронный>
#Максимальное значение:# 2.55 секунд
#Окно для взаимодействия:# {Таймер}

Протокол обмена информацией:
#*# С помощью out 0x16 производим запись нужного нам количества секунд. После выполнение инструкции таймер начинает уменьшать это значение в режиме реального времени. Устанавливаемое значение (INPUT) переводится в секунды по следующей формуле (Timer = INPUT * 0.01).
#*# С помощью in 0x16 производим чтение значения из таймера.

[BEGIN_CODE] [Установка]
mvi A, 100   ; Время 100 * 0.01 = 1.00 (секунда)
out 0x16     ; Заводим таймер на 1 секунду
hlt
[END_CODE]

[BEGIN_CODE] [Чтение]
in 0x16      ; Читаем оставшиеся время из таймера
hlt
[END_CODE]

[END]
[END]