#
Регистры
 A  - 8-разрядный регистр аккумулятор. Все арифметические и логические операции 
производятся только между регистром A и другими регистрами или между регистром A 
и байтом непосредственных данных.
 B  - 8-разрядный регистр общего назначения. Старший регистр регистровой пары BC.
 C  - 8-разрядный регистр общего назначения. Младший регистр регистровой пары BC.
 D  - 8-разрядный регистр общего назначения. Старший регистр регистровой пары DE.
 E  - 8-разрядный регистр общего назначения. Младший регистр регистровой пары DE.
 H  - 8-разрядный регистр общего назначения. Старший регистр регистровой пары HL.
 L  - 8-разрядный регистр общего назначения. Младший регистр регистровой пары HL.
 M  - Значение памяти по адресу H и L
 PC - счётчик команд, содержит адрес очередной исполняемой команды.	
 SP - указатель стека. Указатель стека автоматически декрементируется на 2 при 
записи пары регистров в стек (отдельный 8-разрядный регистр в стек записать 
нельзя, только парами) и инкрементируется при извлечении регистровой пары из стека.
 F  - регистр флагов. Непосредственно недоступен программисту, но его в составе 
регистровой пары PSW можно сохранить в стеке, а потом извлечь в другую регистровую 
пару, если нужно специально установить или проверить нужные флаги.
#
#
Регистровые пары
 BC  - регистровая пара, состоящая из двух 8-разрядных регистров 
(B - старший регистр, C - младший).
 DE  - регистровая пара, состоящая из двух 8-разрядных регистров 
(D - старший регистр, E - младший).
 HL  - регистровая пара, состоящая из двух 8-разрядных регистров 
(H - старший регистр, L - младший), используется для косвенно-регистровой адресации 64 Кбайт памяти.
 PSW - регистровая пара, состоящая из двух 8-разрядных регистров 
(A (аккумулятор) - старший регистр, F (регистр флагов) - младший).
#
#
Флаги
 Carry - флаг переноса (реагирует на переполнение регистра А ).
 Zero - равенство результата операции нулю.
 Sign - знак операции (реагирует на последний 8-ой бит регистра А ).
 Paruty - паритет ( чётность количества единиц в регистре А ).
#
#
Обозначения
 (r) - регистры (A,B,C,D,E,H,L,M)
 (rp) - пары регистров (B, D, H)
 (b8) - (8 бит) значение (0x00 - 0xFF)(0 - 256)
 (b16) - (16 бит) значение (0x0000 - 0xFFFF)(0 - 65536)
 (adr)* - (название маркера) (ну или полноценный адрес 0x0000 - 0xFFFF) 
#
#
Команды пересылки данных
 MOV  (r, r)    - пересылка данных между регистрами общего назначения или между регистром и ячейкой памяти.
 MVI  (r, b8)   - загрузка константного значения (байта) в регистр общего назначения.
 LXI  (rp, b16) - загрузка константного значения (двойного байта) в регистровую пару.
 LDA  (b16)     - прямая загрузка значения ячейки памяти в аккумулятор.
 LHLD (b16)     - прямая загрузка значений ячеек памяти в пару регистров HL.
 STA  (b16)     - прямая запись содержимого регистра А в ячеку памяти.
 SHLD (b16)     - прямая запись содержимого пары регистров HL в ячейку памяти.
 LDAX (B, D)     - косвенная загрузка содержимого ячейки памяти в регистр А через адрес, хранящийся в BC/DE.
 STAX (B, D)     - косвенная запись содержимого регистра А в ячейку памяти через адрес, хранящийся в BC/DE.
 XCHG           - обмен значениями между парами регистров HL и DE.
#
#
Суммирование и инкременты
 ADD (r)   - сложение [A = A + r].
 ADI (b8)  - сложение с константой [A = A + b8].
 ADC (r)   - сложение с учётом переноса [A = A + r + Carry].
 ACI (b8)  - сложение с константой с учётом переноса [A = A + b8 + Carry].
 INR (r)   - инкремент [r = r + 1].
 INX (rp)  - инкремент пары регистров [rp = rp + 1].
 DAD (rp)  - сложение пары регистров [HL = HL + rp]. 
#
#
Вычитание и декременты
 SUB (r)   - вычитание [A = A - r].
 SUI (b8)  - вычитание константы [A = A - b8].
 SBB (r)   - вычитание с учётом переноса [A = A - r - Carry].
 SBI (b8)  - вычитание константы с учётом переноса [A = A - b8 - Carry].
 DCR (r)   - декремент [r = r - 1]. 
 DCX (rp)  - декремент пары регистров [rp = rp - 1].
#
#
Логические
 ANA (r) - логическое И [A = A & r].
 ANI (b8) - логическое И с константой [A = A & b8].
 ORA (r) - логическое ИЛИ [A = A | r].
 ORI (b8) - логическое ИЛИ с константой.
 XRA (r) - исключающее ИЛИ [A = A ^ r].
 XRI (b8) - исключающее ИЛИ с константой [A = A ^ b8].
 RLC - циклический сдвиг аккумулятора влево.
 RRC - циклический сдвиг аккумулятора вправо.
 RAL - арифметический сдвиг влево через перенос.
 RAR - арифметический сдвиг вправо через перенос.
 CMA - инвертирование содержимого регистра А [ A = ! A ].
 STC - установка флага переноса (Carry) в 1.
 CMC - инвертирование флага переноса (Carry).
#
#
Сравнения
 CMP (r) - сравнение с регистром.
 СPI (b8) - сравнение с константой.
#
#
Вызовы подпрограммы
 CALL (adr)* - вызов подпрограммы по адресу.
 CNZ (adr)* - вызов подпрограммы по адресу, если флаг Zero = 0.
 CZ (adr)* - вызов подпрограммы по адресу, если флаг Zero = 1.
 CNC (adr)* - вызов подпрограммы по адресу, если флаг Carry = 0.
 CC (adr)* - вызов подпрограммы по адресу, если Carry = 1.
 CPO (adr)* - вызов подпрограммы по адресу, если Paruty = 0.
 CPE (adr)* - вызов подпрограммы по адресу, если Paruty = 1.
 CP (adr)* - вызов подпрограммы по адресу, если Sign = 0.
 CM (adr)* - вызов подпрограммы по адресу, если Sign = 1.
#
#
Возвраты из подпрограммы
 RET - возврат из подпрограммы.
 RNZ - возврат из подпрограммы, если Zero = 0.
 RZ - возврат из подпрограммы, если Zero = 1
 RNC - возврат из подпрограммы, если Carry = 0.
 RC - возврат из подпрограммы, если Carry = 1.
 RPO - возврат из подпрограммы, если Paruty = 0.
 RPE - возврат из подпрограммы, если Paruty = 1.
 RP - возврат из подпрограммы, если Sign = 0.
 RM - возврат из подпрограммы, если Sign = 1.
#
#
Переходы (прыжки)
 JMP (adr)* - безусловный переход.
 JZ (adr)* - переход, если Zero = 1.
 JNZ (adr)* - переход, если Zero = 0.
 JC (adr)* - переход, если Carry = 1.
 JNC (adr)* - переход, если Carry = 0.
 JP (adr)* - переход, если Sign = 0.
 JM (adr)* - переход, если Sign = 1.
 JPO (adr)* - переход, если Paruty = 0.
 JPE (adr)* - переход, если Paruty = 1.
#
#
Управления вводом/выводом
 IN (b8)  - чтение значения из порта в аккумулятор.
 OUT (b8)  - запись значения в порт из аккумулятора.
#
#
Работа со стеком и не только
 PCHL - переход по адресу из пары регистров HL.
 SPHL - загрузка содержимого из пары регистров HL в указатель стека (SP)
 PUSH (rp) - загрузка содержимого пары регистров (BC, DE, HL, PSW) в стек.
 POP (rp) - загрузка содержимого из вершины стека в пару регистров (BC, DE, HL, PSW).
 XTHL - обмен между вершиной стека и парой регистров HL.
 NOP - нет операции.
 HLT - остановка процессора.
#
#
Mаркеры
 Маркеры или же метки (пример "Main: ") - это один из способов задания адреса, но в отличии от абсолютного адреса (пример: 0x00FA),
адрес маркера определяется на этапе трансляции кода.

 Примечание: маркеры чуствительны к регистру ("Main" != "MAIN"). метка без точки в начале называется "глобальной меткой"
 
 Пример использование "глобальных" меток:

  Main:
   MVI A,16
   Loop:
    DCR A
    JZ End
    JMP Loop
   End:
    HLT

 Также в программе реализованны локальные метки.

 Локальная метка - это метка имя которой начинается с точки. Во время трансляции кода к именам локальных меток добавляется 
к началу имя последней "глобальной" метки. Таким образом, имена локальных меток могут повторяться, если между ними есть хотя
бы одна «глобальная» метка.

 Пример с использование "локальных" меток:
  Main:
   CALL Cycle_16
   CALL Cycle_32
   HLT

  Cycle_16:
   MVI A,16
   .loop:
    DCR A
    JZ End
    JMP Loop
   .end:
    RET

  Cycle_32:
   MVI A,32
   .loop:
    DCR A
    JZ End
    JMP Loop
   .end:
    RET
#
#
Дерективы транслятора
    * .set:0x(XX)   – директива загрузки в ячейку памяти микропроцессора значения (байта). Используется для формирования в памяти 
		      массива данных.
    * .adr:0x(XXXX) – директива установки адреса. Команды и данные, следующие за этой директивой будут загружены в память начиная 
		      с указанного в директиве адреса.

	Пример:
	
	.adr:0x0010
	MVI A, 0xFF	; загрузка в ячейки 0x0010 и 0x0011 команды MVI A, 0xFF (2 байта)
	MVI B, 0xCC	; загрузка в ячейки 0x0012 и 0x0013 команды MVI B, 0xCC (2 байта)
	CPI B		; загрузка в ячейку 0x0014 команды CPI B 		 (1 байт)
	HLT		; загрузка в ячейку 0x0015 команды HLT 			 (1 байт)

	.adr:0x0F00
	.set:0x0A       ; загрузка в ячейку 0x0F00 данных 0x0A
	.set:0x0B	; загрузка в ячейку 0x0F01 данных 0x0B
	.set:0x0C	; загрузка в ячейку 0x0F02 данных 0x0C

	Команды в данном примере будут загружены в память микропроцессора начиная с адреса 0x0010.
	Данные в данном примере будут загружены в память микропроцессора начиная с адреса 0x0F00.
#
#
Ввод с клавиатуры
 Команда чтения значения из порта 0x08 (IN 0x08) осуществляет запрос на ввод значения с клавиатуры.
#
#
Вывод в консоль
 Команда записи значения в порт 0x02 (OUT 0x02) осуществляет вывод значения в консоль.
#
#
Таймер
    Эмулятор Intel 8080 поддерживает работу с таймером.
    Установка таймера производится с точностью до 0.01 секунды. 
    Максимальное время одного цикла работы таймера составляет 2.55 секунды = 255 * 0.01.
    Обмен информацией с таймером осуществляется через порт 0x16. Запись значения в порт 0x16 (OUT 0x16) выполняет программирование таймера. 
    После выполнения этой команды таймер начинает обратный отсчёт (значение таймера декрементируется каждую 0.01 секунды). Чтение значения 
    из порта 0x16 (IN 0x16) позволяет получить текущее значение таймера.
#
#
Символьный экран
    Эмулятор Intel 8080 позволяет работать с символьным экраном разрешением 20x20 пикселей.
    Каждый пиксель экрана может отображать 1 из 8 цветов (фон) и символ из таблицы ASCII 1251 (1 из 8 цветов).
    Взаимодействие с экраном осуществляется через порт 0x07.
    
    Протокол обмена информацией:

      1. Записать в порт 0x07 номер строки символьного экрана (0 - 19).
      2. Записать в порт 0x07 номер столбца символьного экрана (0 - 19).
      3. Выбрать режим записи/чтения. (0x00 – запись, любое другое значение – чтение).
      4. Записать/прочитать значение цвета фона и цвета символа выбранного пикселя экрана (цвет фона кодируется по упрощенной модели RGB
	 пятым, четвёртым и третьим битами: 0bxxRGBxxx; цвет символа кодируется по упрощенной модели RGB вторым, первым и нулевым битами:
         0bxxxxxRGB). Цвет фона и цвет пикселя передаются одним байтом.
      5. Записать/прочитать значение кода символа выбранного пикселя экрана (Код символа таблицы ASCII 1251).

	Пример вывода на экран символа '$' в зелёном цвете на синем фоне в пикселе с координатами [Row: 1, Column: 3]:

	MVI A, 0x01		; номер строки пикселя
	OUT 0x07		; запись номера строки
	MVI A, 0x03		; номер столбца пикселя
	OUT 0x07		; запись номера столбца
	MVI A, 0x00		; загрузка нулевого значения в регистр (режим записи)
	OUT 0x07		; запись нулевого значения в экран (установка режима записи)
	MVI A, 0b00001010	; загрузка кода цвета фона (0bxx001xxx - синий) и цвета символа (0bxxxxx010 - зелёный).
	OUT 0x07		; запись значения цвета фона и цвета символа
	MVI A, 0x24		; загрузка кода символа '$' согласно таблицы ASCII 1251
	OUT 0x07		; запись значения кода символа
#
#
Пиксельный экран
    Эмулятор Intel 8080 позволяет работать с экраном с разрешением 256x256 пикселей.
    Каждый пиксель экрана может отображать 1 из 256 возможных цветов.
    Взаимодействие с экраном осуществляется через порт 0x05.
    
    Протокол обмена информацией:

      1. Записать в порт 0x05 номер строки пиксельного экрана (0 - 255).
      2. Записать в порт 0x05 номер столбца пиксельного экрана (0 - 255).
      3. Выбрать режим записи/чтения. (0x00 – запись, любое другое значение – чтение).
      4. Записать/прочитать значение цвета выбранного пикселя экрана.

      Пример установки пикселя с координатами [Row: 10, Column: 15] в синий цвет:

	MVI A, 0x0A		; номер строки пикселя
	OUT 0X05		; запись номера строки
	MVI A, 0X0F		; номер столбца пикселя
	OUT 0X05		; запись номера столбца
	MVI A, 0X00		; загрузка нулевого значения в регистр (режим записи)
	OUT 0X05		; запись нулевого значения (установка режима записи)
	MVI A, 0b00000111	; загрузка значения цвета пикселя (цвет пикселя кодируется по упрощенной модели RGB: 0bRRGGGBBB)
	OUT 0X05		; запись значения цвета пикселя

      Пример чтения значения пикселя с координатами [Row: 10, Column: 15]:

	MVI A, 0x0A		; номер строки пикселя
	OUT 0X05		; запись номера строки
	MVI A, 0X0F		; номер столбца пикселя
	OUT 0X05		; запись номера столбца
	MVI A, 0XFF		; загрузка значения отличного от нуля в регистр (режим чтения)
	OUT 0X05		; запись значения(установка режима чтения)
	IN 0x05			; чтение значения пикселя
#
#
Генератор
    Эмулятор Intel 8080 поддерживает работу с Рандомным генератором.
    Генератор может генерировать значение от 0 до 255.
    
    Протокол взаимодействия с генератором:
	1. Записать в порт 0x09 диапазон генерации значение (от 0 до 255)
	2. Прочитать сгенирированного значения
    
    Для генерации нового числа, нужно произвести шаги протокола заново
    
    Пример использования:
	MVI A, 16   ; Диапозон для генератора
	OUT 0x09    ; Запись диапазона в генератор
	IN 0x09     ; Чтение сгенирированного значения
#