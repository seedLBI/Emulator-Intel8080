#include "Help.Data.h"


const std::string str_data_help = u8R"(
[ABBRIV_MEAN] [A] [8-разрядный регистр, аккумулятор]
[ABBRIV_MEAN] [B] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [C] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [D] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [E] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [H] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [L] [8-разрядный регистр общего назначения]
[ABBRIV_MEAN] [M] [Значение памяти по адресу <H> и <L>. Индекс вычисляется так: Memory<H*256 + L>]
[ABBRIV_MEAN] [F] [Регистр флагов]

[ABBRIV_MEAN] [PC] [указатель выполняемой команды]
[ABBRIV_MEAN] [SP] [указатель стека]

[ABBRIV_MEAN] [BC]  [регистровая пара (B - старший регистр, C - младший)]
[ABBRIV_MEAN] [DE]  [регистровая пара (D - старший регистр, E - младший)]
[ABBRIV_MEAN] [HL]  [регистровая пара (H - старший регистр, L - младший)]
[ABBRIV_MEAN] [PSW] [регистровая пара (A - аккумулятор старший регистр, F - младший регистр флагов)]

[ABBRIV_MEAN] [Carry]          [Перенос (реагирует на переполнение регистра A)]
[ABBRIV_MEAN] [Zero]           [Равенство результата арифм. операции нулю]
[ABBRIV_MEAN] [Sign]           [Знак операции (реагирует на последний 8-ой бит регистра А)]
[ABBRIV_MEAN] [Paruty]         [Паритет (чётность количества единиц в регистре A)]
[ABBRIV_MEAN] [Auxilary Carry] [Вспомогательный перенос (реагирует на перенос из 4-го бита в 5-й)]

[ABBRIV_MEAN] [r]   [регистры (A, B, C, D, E, H, L, M)]
[ABBRIV_MEAN] [rp]  [пары регистров (B == BC, D == DE, H == HL)]
[ABBRIV_MEAN] [b8]  [(8 бит) значение (0x00 - 0xFF)(0 - 256)(название константы)]
[ABBRIV_MEAN] [b16] [(16 бит) значение (0x0000 - 0xFFFF)(0 - 65536)(название константы, маркера)]
[ABBRIV_MEAN] [adr] [(название маркера, константы, или полноценный адрес 0x0000 - 0xFFFF)]
[ABBRIV_MEAN] [N]   [Число от 0 до 8]


[ABBRIV_MEAN] [.adr:]   [Деректива транслятора, отвечающая за установку начала адресов последующих команд]
[ABBRIV_MEAN] [.set:]   [Деректива транслятора, отвечающая за установку байта данных на текущий адрес]
[ABBRIV_MEAN] [.const:] [Деректива транслятора, отвечающая за добавление в список постоянных, постоянной...]

[ABBRIV_MEAN] [Асинхронный] [Выполняется без остановок процессора]
[ABBRIV_MEAN] [Cинхронный]  [Выполняется с остановками процессора, дожидаясь действий со стороны пользовтеля]


[ABBRIV_MEAN] [ЛКМ] [Левая кнопка мыши]
[ABBRIV_MEAN] [ПКМ] [Правая кнопка мыши]
[ABBRIV_MEAN] [СКМ] [Средняя кнопка мыши (колёсико)]


[BEGIN_CATEGORY] [Регистры]
<A>  - 8-разрядный регистр, аккумулятор. Все арифметические и логические операции производятся только между регистром <A> и другими регистрами или между регистром <A> и байтом непосредственных данных.
<B>  - 8-разрядный регистр общего назначения. Старший регистр регистровой пары <BC>.
<C>  - 8-разрядный регистр общего назначения. Младший регистр регистровой пары <BC>.
<D>  - 8-разрядный регистр общего назначения. Старший регистр регистровой пары <DE>.
<E>  - 8-разрядный регистр общего назначения. Младший регистр регистровой пары <DE>.
<H>  - 8-разрядный регистр общего назначения. Старший регистр регистровой пары <HL>.
<L>  - 8-разрядный регистр общего назначения. Младший регистр регистровой пары <HL>.
<M>  - Значение памяти по адресу <H> и <L>. Индекс вычисляется так: Memory[<H> * 256 + <L>].
<PC> - Указатель на адрес текущей выполняемой команды.
<SP> - Указатель стека. Указатель стека автоматически декрементируется на 2 при записи пары регистров в стек (отдельный 8-разрядный регистр в стек записать нельзя, только парами) и инкрементируется при извлечении регистровой пары из стека.
<F>  - Регистр флагов. Непосредственно недоступен программисту, но его в составе регистровой пары <PSW> можно сохранить в стеке, а потом извлечь в другую регистровую пару, если нужно специально установить или проверить нужные флаги.
Описание битов регистра F:
| S  | Z  | #==# | AC | #==# | P  | #==# | C  |
S  - <Sign>
Z  - <Zero>
AC - <Auxilary Carry>
P  - <Paruty>
C  - <Carry>
[END]

[BEGIN_CATEGORY] [Регистровые пары]
<BC>  - (<B> - старший регистр, <C> - младший).
<DE>  - (<D> - старший регистр, <E> - младший).
<HL>  - (<H> - старший регистр, <L> - младший), используется для косвенно-регистровой адресации 64 Кбайт памяти.
<PSW> - (<A> (аккумулятор) - старший регистр, <F> (регистр флагов) - младший).
[END]

[BEGIN_CATEGORY] [Флаги]
<Carry>  - перенос ( реагирует на переполнение регистра <A> ).
<Zero>   - равенство результата операции нулю. [<A> == 0]
<Sign>   - знак операции ( реагирует на последний 8-ой бит регистра <A> ).
<Paruty> - паритет ( чётность количества единиц в регистре <A> ).
<Auxilary Carry> - вспомогательный перенос (реагирует на перенос из 4-го бита в 5-й).
[END]

[BEGIN_CATEGORY] [Обозначения]
(<r>)   - регистры (<A>, <B>, <C>, <D>, <E>, <H>, <L>, <M>)
(<rp>)  - пары регистров (<B> == <BC>, <D> == <DE>, <H> == <HL>)
(<b8>)  - (8 бит) значение (0x00 - 0xFF)(0 - 256)(название константы)
(<b16>) - (16 бит) значение (0x0000 - 0xFFFF)(0 - 65536)(название константы)
(<adr>) - (название маркера, константы, или полноценный адрес 0x0000 - 0xFFFF) 
[END]



[BEGIN_CATEGORY] [Команды]
[BEGIN] [Команды пересылки данных]
#mov#  (<r>, <r>) - пересылка данных между регистрами общего назначения или между регистром и ячейкой памяти.
#mvi#  (<r>, <b8>) - загрузка константного значения (байта) в регистр общего назначения. [<r> = <b8>]
#lxi#  (<rp>, <b16>) - загрузка константного значения в регистровую пару. [<rp> = <b16>]
#lda#  (<b16>) - прямая загрузка значения ячейки памяти в аккумулятор. [<A> = <M>]
#lhld# (<b16>) - прямая загрузка значений ячеек памяти в пару регистров <HL>. [<HL> = <M>]
#sta#  (<b16>) - прямая запись содержимого регистра <A> в ячеку памяти. [<M> = <A>]
#shld# (<b16>) - прямая запись содержимого пары регистров <HL> в ячейку памяти. [<M> = <HL>]
#ldax# (<BC>\<DE>) - косвенная загрузка содержимого ячейки памяти в регистр <A> через адрес, хранящийся в <BC> или <DE>.
#stax# (<BC>\<DE>) - косвенная запись содержимого регистра <A> в ячейку памяти через адрес, хранящийся в <BC> или <DE>.
#xchg# - обмен значениями между парами регистров <HL> и <DE>. [swap(<HL>,<DE>)]
#pchl# - загрузка содержимого пары регистров <HL> в регистр <PC>. [<PC> = <HL>] 
#sphl# - загрузка содержимого пары регистров <HL> в регистр <SP>. [<SP> = <HL>]
[END]

[BEGIN] [Суммирование и инкременты]
#add# (<r>)  - сложение [<A> = <A> + <r>].
#adi# (<b8>) - сложение с константой [<A> = <A> + <b8>].
#adc# (<r>)  - сложение с учётом переноса [<A> = <A> + <r> + <Carry>].
#aci# (<b8>) - сложение с константой с учётом переноса [<A> = <A> + <b8> + <Carry>].
#inr# (<r>)  - инкремент [<r> = <r> + 1].
#inx# (<rp>) - инкремент пары регистров [<rp> = <rp> + 1].
#dad# (<rp>) - сложение пары регистров [<HL> = <HL> + <rp>]. 
[END]

[BEGIN] [Вычитание и декременты]
#sub# (<r>)  - вычитание [<A> = <A> - <r>].
#sui# (<b8>) - вычитание константы [<A> = <A> - <b8>].
#sbb# (<r>)  - вычитание с учётом переноса [<A> = <A> - <r> - <Carry>].
#sbi# (<b8>) - вычитание константы с учётом переноса [<A> = <A> - <b8> - <Carry>].
#dcr# (<r>)  - декремент [<r> = <r> - 1]. 
#dcx# (<rp>) - декремент пары регистров [<rp> = <rp> - 1].
[END]

[BEGIN] [Логические]
#ana# (<r>)  - Логическое И [<A> = <A> & <r>].
#ani# (<b8>) - Логическое И с константой [<A> = <A> & <b8>].
#ora# (<r>)  - Логическое ИЛИ [<A> = <A> | <r>].
#ori# (<b8>) - Логическое ИЛИ с константой.
#xra# (<r>)  - Исключающее ИЛИ [<A> = <A> ^ <r>].
#xri# (<b8>) - Исключающее ИЛИ с константой [<A> = <A> ^ <b8>].
#daa# - Корректирует содержимое регистра <A> для соответствия формату BCD
#rlc# - Циклический сдвиг аккумулятора влево.
#rrc# - Циклический сдвиг аккумулятора вправо.
#ral# - Арифметический сдвиг влево через перенос.
#rar# - Арифметический сдвиг вправо через перенос.
#cma# - Инвертирование содержимого регистра <A>. [<A> = !<A>].
#stc# - Установка флага переноса (<Carry>) в 1. [<Carry> = 1]
#cmc# - Инвертирование флага переноса (<Carry>). [<Carry> = !<Carry>]
[END]
)"
u8R"(
[BEGIN] [Сравнения]
#cmp# (<r>)  - сравнение регистра <A> с выбранным регистром <r>.
#cpi# (<b8>) - сравнение регистра <A> с константой.

При сравнение мы по сути вычитаем из регистра <A> выбранное значение (регистр или константа). Результат этой арифмитической операции отражается на флагах. При этом результат операции не присвается регистру <A>.

[BEGIN_CODE] [Значения флагов при выполнении команды сравнения]
___________________________________________
|                         |    Признак    |
|   Результат сравнения   |---------------|
|                         |  Zero | Carry |
|-------------------------+-------+-------|
| Равно                   |   1   |   0   |
|-------------------------+-------+-------|
| Больше                  |   0   |   0   |
|-------------------------+-------+-------|
| Меньше                  |   0   |   1   |
|-------------------------|-------|-------|
[END_CODE]
[END]

[BEGIN] [Вызовы подпрограммы]
#call#(<adr>) - вызов подпрограммы по адресу.
#rst# (<N>)   - вызов подпрограммы по адресу N*8. [rst N == call N*8]. 
#cz#  (<adr>) - вызов подпрограммы по адресу, если <Zero> = 1.
#cnz# (<adr>) - вызов подпрограммы по адресу, если <Zero> = 0.
#cm#  (<adr>) - вызов подпрограммы по адресу, если <Sign> = 1.
#cp#  (<adr>) - вызов подпрограммы по адресу, если <Sign> = 0.
#cc#  (<adr>) - вызов подпрограммы по адресу, если <Carry> = 1.
#cnc# (<adr>) - вызов подпрограммы по адресу, если <Carry> = 0.
#cpe# (<adr>) - вызов подпрограммы по адресу, если <Paruty> = 1.
#cpo# (<adr>) - вызов подпрограммы по адресу, если <Paruty> = 0.
[END]

[BEGIN] [Возвраты из подпрограммы]
#ret# - возврат из подпрограммы.
#rz#  - возврат из подпрограммы, если <Zero> = 1.
#rnz# - возврат из подпрограммы, если <Zero> = 0.
#rm#  - возврат из подпрограммы, если <Sign> = 1.
#rp#  - возврат из подпрограммы, если <Sign> = 0.
#rc#  - возврат из подпрограммы, если <Carry> = 1.
#rnc# - возврат из подпрограммы, если <Carry> = 0.
#rpe# - возврат из подпрограммы, если <Paruty> = 1.
#rpo# - возврат из подпрограммы, если <Paruty> = 0.
[END]

[BEGIN] [Переходы (прыжки)]
#jmp# (<adr>) - безусловный переход.
#jz#  (<adr>) - переход, если <Zero> = 1.
#jnz# (<adr>) - переход, если <Zero> = 0.
#jc#  (<adr>) - переход, если <Carry> = 1.
#jnc# (<adr>) - переход, если <Carry> = 0.
#jm#  (<adr>) - переход, если <Sign> = 1.
#jp#  (<adr>) - переход, если <Sign> = 0.
#jpe# (<adr>) - переход, если <Paruty> = 1.
#jpo# (<adr>) - переход, если <Paruty> = 0.
[END]


[BEGIN] [Управления вводом/выводом]
#in# (<b8>) - чтение значения из порта в аккумулятор <A>.
#out#(<b8>) - запись значения из аккумулятора <A> в порт.
[END]

[BEGIN] [Работа со стеком и не только]
#push# (<rp>) - загрузка содержимого пары регистров (<BC>, <DE>, <HL>, <PSW>) в стек.
#pop#  (<rp>) - извлечение содержимого из вершины стека в пару регистров (<BC>, <DE>, <HL>, <PSW>).
#xthl# - обмен между вершиной стека и парой регистров <HL>.
#nop#  - нет операции.
#hlt#  - остановка процессора.
[END]
[END]




[BEGIN_CATEGORY] [Метки\\Маркеры]
[BEGIN] [Глобальные]
Маркеры или же метки (пример "Main: ") - это один из способов задания адреса, но в отличии от абсолютного адреса (пример: 0x00FA), адрес маркера определяется на этапе трансляции кода.

Примечание: маркеры чуствительны к регистру ("Main" != "MAIN"). метка без точки в начале называется "глобальной меткой"

[BEGIN_CODE] [Пример "глобальных" меток]
Main:
	mvi A,16
Loop:
	dcr A
	jz End
	jmp Loop
End:
	hlt
[END_CODE]
[END]

[BEGIN] [Локальные]
Локальная метка - это метка имя которой начинается с точки. Во время трансляции кода к началу имён локальных меток добавляется имя последней "глобальной" метки. Таким образом, имена локальных меток могут повторяться, если между ними есть хотя бы одна "глобальная" метка.

[BEGIN_CODE] [Пример "локальных" меток]
Main:
	call Cycle_16
	call Cycle_32
	mvi a, 10
	call Cycle_16.loop ; Так же можно задать
					   ; локальный адрес напрямую
	hlt

Cycle_16:
	mvi A,16
	.loop:		; .loop: = Cycle_16.loop:
		dcr A
		jz .end
		jmp .loop
	.end:		; .end: = Cycle_16.end:
		ret

Cycle_32:
	mvi A,32
	.loop:		; .loop: = Cycle_32.loop:
		dcr A
		jz .end
		jmp .loop
	.end:		; .end: = Cycle_32.end:
		ret
[END_CODE]
[END]
[END]




[BEGIN_CATEGORY] [Дерективы транслятора]

[BEGIN] [.adr:]
<.adr:> value - директива установки адреса (2 байта). Команды и данные, следующие за этой директивой будут загружены в память начиная с указанного в директиве адреса.

Пример, как при помощи .adr будут распологаться байты в памяти после компиляции:

[BEGIN_CODE] [Пример]
.adr: 0x0010

mvi A, 0xFF  ;0x0010 0x0011
mvi B, 0xCC  ;0x0012 0x0013
cpi B        ;0x0014
hlt          ;0x0015
[END_CODE]
[END]



[BEGIN] [.set:]
<.set:> value - директива загрузки в ячейку памяти микропроцессора значения (байта). Используется для формирования в памяти массива данных.

Значение могут быть введены в следующих форматах

[BEGIN_CODE] [Возможные форматы]
.set: 0b00001010 ; двоичный
.set: 123        ; десятичный
.set: 0x15       ; шестнадцитиричный
.set: "a"        ; символный (каждый символ переводится в значение таблицы ASCII 1251)
[END_CODE]

Также можно перечеслять в одну строку несколько значений

[BEGIN_CODE] [Примеры]
.set: 0x01, 0x02, 0x10, 0xff
.set: "Можно ввести целую строку! ", "о", "дааа"
.set: 0b00101, "можно комбинировать", 228, 0xf1
[END_CODE]
[END]



[BEGIN] [.const:]
<.const:> const_name value - деректива создания макроса\константы которое преобразуется в соответсвующее ей число(1 или 2 байта) на этапе компиляции.

[BEGIN_CODE] [Пример]
.const: port_screen 0x05
.const: mode_load 0x00

jmp Main

Main:
	mvi a, 0x0a
	out port_screen   ; = out 0x05
	mvi a, mode_load  ; = mvi a, 0x00
	out port_screen   ; = out 0x05
[END_CODE]
[END]

[END]




)"
u8R"(




[BEGIN_CATEGORY] [Описание окон]

[BEGIN] [Редактор кода]
Реализует редактор кода с подсветкой синтаксиса для каждой категории команд (дерективы, комментарии, маркеры, разные инструкции).
Реализованы разные популярные комбинации клавиш для копирования, вставки, выделения.
При наведению на подсвеченную инструкцию выводится её краткая информация (описание работы, кол - во байт, типы аргументов и т.д).

#Комментарии#:
Однострочные  начинаются с символа #;#.
Многострочные начинаются с #/*#, а заканчиваются #*/#.

Так же есть поиск, который открывается при активном окне {Редактор кода} сочитанием клавиш CTRL+F.

[END]

[BEGIN] [Просмотр мнемо кода]
Реализует вывод памяти процессора в формате мнемокодов, значения или адреса. которых были взяты из редактора кода, что может быть удобно при навегации по памяти..
[END]

[BEGIN] [Hex просмотр]
Реализует вывод памяти процессора в шестнадцетиричном формате.
Может взаимодействовать с процессом эмуляции при помощи мыши:
При нажатии на ячейку адреса памяти:
<ЛКМ> - Регистр PC изменится на соответствующий адрес
<ПКМ> - Добавит точку останова на соответствующий адрес.
[END]

[BEGIN] [Пиксельный экран]
Реализует вывод состояния внешнего устройства #Пиксельный экран#.
С помощью нажатия <ПКМ> можно открыть меню в котором можно настроить отображение.
[END]

[BEGIN] [Продвинутый пиксельный экран]
Реализует вывод состояния внешнего устройства #Продвинутый пиксельный экран#.
С помощью нажатия <ПКМ> можно открыть меню в котором можно настроить отображение.
[END]

[BEGIN] [Символьный экран]
Реализует вывод состояния внешнего устройства #Символьный экран#.
При наведении на любую ячейку экрана производится вывод её информации.
С помощью нажатия <ПКМ> можно открыть меню в котором можно настроить отображение.
[END]

[BEGIN] [Таймер]
Взаимодействует с внешним устройством (Таймер) и отображает его текущее значение.
[END]

[BEGIN] [Окно вывода]
Взаимодействует с внешним устройством #Окно вывода#. Отображает все полученные значение за сеанс эмуляции.
[END]

[BEGIN] [Окно ввода]
Взаимодействует с внешним устройством #Окно ввода# и реализует возможность ввода 8 битных значений.
[END]

[BEGIN] [Окно клавиатуры]
Отображает кнопки которые может считывать внешнее устройство #Клавиатура#.
[END]

[BEGIN] [Все цвета]
Отображает все возможные цвета для упрощённой модели RGB[0brrgggbbb].
Может взаимодействовать с окном {Редактор кода}, с помощью <ЛКМ> будет производится копирование значения выбранного цвета на позицию текущего курсора в редакторе.
[END]

[BEGIN] [Все символы]
Отображает все символы кодировки ASCII1251.
Может взаимодействовать с окном {Редактор кода}, с помощью <ЛКМ> будет производится копирование значения выбранного символа на позицию текущего курсора в редакторе.
[END]

[BEGIN] [Регистры и флаги]
Отображает состояния процессора на текущий момент времени.
[END]

[BEGIN] [Быстродействие]
Отображает различные метрики работы процессора
[END]

[BEGIN] [Список маркеров]
Отображает список маркеров, которые встретились при компиляции.
Может взаимодействовать с окном {Мнемо код} и самим процессором.
При нажатии на маркер:
<ЛКМ> - Регистр PC изменится на соответствующий адрес и слайдер наведётся на нужный адрес в окне #Мнемо код#
<ПКМ> - Добавит точку останова на соответствующий адрес.
<СКМ> - Слайдер наведётся на нужный адрес в окне #Мнемо код#
[END]

[BEGIN] [Список переменных]
Отображает список переменных, которые встретились при компиляции.
Переменной будет являться тот байт который установленн с помощью <.set:> который идёт сразу после маркера.

[BEGIN_CODE][Пример переменной]
.name_var: ; глобальный маркер
.set: 0    ; значение в памяти
[END_CODE]

Польза этого списка заключается в том, что значение переменных иземеняются в реальном времени вслед за эмуляцией, что может быть удобно при отладке программы.
[END]

[BEGIN] [Список постоянных]
Отображает список постоянных, которые встретились при компиляции.
Постоянные это те значение которые были созданы с помощью дерективы <.const:>
[END]

[END]










[BEGIN_CATEGORY] [Внешние устройства]


[BEGIN] [(0x02) Вывод в консоль]
#Порт:# 0x02
#Тип взаимодействия:# <Асинхронный>
#Окно для взаимодействия:# {Окно вывода}

Протокол обмена информацией:
Команда записи значения в порт 0x02 (OUT 0x02) осуществляет вывод значения в консоль.

[BEGIN_CODE] [Отправка значения в консоль]
mvi a, 228
out 0x02   ; Число 228 отобразиться в консоли
[END_CODE]
[END]


[BEGIN] [(0x08) Ввод с клавиатуры]
#Порт:# 0x08
#Тип взаимодействия:# <Cинхронный>
#Окно для взаимодействия:# {Окно ввода}

Протокол обмена информацией:
Команда чтения значения из порта 0x08 (IN 0x08) осуществляет запрос на ввод значения с клавиатуры. При этом выполнение следующей инструкции замороженно до тех пор пока пользователь не введёт значение.

[BEGIN_CODE] [Пример]
in 0x08 ; ждём ввода от пользователя
        ; введённое значение переместится в регистр А
[END_CODE]
[END]

[BEGIN] [(0x09) Генератор рандомных чисел]
#Порт:# 0x09
#Тип взаимодействия:# <Асинхронный>
#Максимальное значение:# 255

Протокол обмена информацией:
#1.# Записать в порт 0x09 диапазон генерации значение (от 0 до 255)
#2.# Прочитать сгенирированного значения

Для генерации нового числа, нужно произвести шаги протокола заново

[BEGIN_CODE] [Запись диапазона и чтение сгенирированного числа]
mvi A, 30   ; Диапозон для генератора
out 0x09    ; Запись диапазона в генератор
in 0x09     ; Чтение сгенирированного значения
[END_CODE]
[END]

)"
u8R"(

[BEGIN] [(0x05) Пиксельный экран]
#Порт:# 0x05
#Тип взаимодействия:# <Асинхронный>
#Разрешение:# 256x256
#Кол-во цветов:# 256 (кодируются по упрощённой модели RGB[0bRRGGGBBB])
#Кол-во буферов:# 1
#Окно для взаимодействия:# {Пиксельный экран}
#Вспомогающее окно:# {Все цвета}

Протокол обмена информацией:
#1.# Записать в порт 0x05 номер строки пиксельного экрана (0 - 255).
#2.# Записать в порт 0x05 номер столбца пиксельного экрана (0 - 255).
#3.# Выбрать режим записи/чтения. (0x00 - запись, любое другое значение - чтение).
#4.# Записать/прочитать значение цвета выбранного пикселя экрана.

Пример установки пикселя с координатами [Row: 10, Column: 15] в синий цвет:

[BEGIN_CODE] [Установка]
mvi A, 0x0A       ; номер строки пикселя
out 0x05          ; запись номера строки
mvi A, 0x0F       ; номер столбца пикселя
out 0x05          ; запись номера столбца
mvi A, 0x00       ; загрузка нулевого значения в регистр (режим записи)
out 0x05          ; запись нулевого значения (установка режима записи)
mvi A, 0b11111111 ; загрузка значения цвета пикселя (цвет пикселя кодируется по упрощенной модели RGB: 0bRRGGGBBB)
out 0x05          ; запись значения цвета пикселя
[END_CODE]

Пример чтения значения пикселя с координатами [Row: 10, Column: 15]:

[BEGIN_CODE] [Чтение]
mvi A, 0x0A  ; номер строки пикселя
out 0x05     ; запись номера строки
mvi A, 0x0F  ; номер столбца пикселя
out 0x05     ; запись номера столбца
mvi A, 0xFF  ; загрузка значения отличного от нуля в регистр (режим чтения)
out 0x05     ; запись значения(установка режима чтения)
in 0x05      ; чтение значения пикселя
[END_CODE]
[END]







[BEGIN] [(0x06) Продвинутый пиксельный экран]
#Порт:# 0x06
#Тип взаимодействия:# <Асинхронный>
#Разрешение:# 256x256
#Кол-во буферов:# 2 (передний - который мы наблюдаем, задний - с которым взаимодействуем)
#Кол-во цветов:# 256 (кодируются по упрощённой модели RGB[0bRRGGGBBB])
#Окно для взаимодействия:# {Продвинутый пиксельный экран}
#Вспомогающее окно:# {Все цвета}

Протокол обмена информацией:
#1.# Записать в порт 0x06 режим (0 - 3) 0 - Установить пиксель, 1 - Прочитать пиксель, 2 - Поменять буферы, 3 - отчистить буферы. Если выбран режим (2) или (3) то начинать сначала
#2.# Записать в порт 0x06 номер строки  (0 - 255)
#3.# Записать в порт 0x06 номер столбца (0 - 255)
Если выбран режим (1) то вызываем in 0x06 и получаем значение пикселя
#4.# Записать в порт 0x06 цвет (в формате 0bRRGGGBBB)


[BEGIN_CODE] [Установка цвета пикселя во второй буфер]
mvi A, 0           ; Режим - установка цвета пикселя
out 0x06           ; Отправляем выбранный режим
mvi A, 0x0F        ; номер строки пикселя  (Y)
out 0x06           ; запись номера строки
mvi A, 0x0F        ; номер столбца пикселя (X)
out 0x06           ; запись номера столбца
mvi A, 0b11111111  ; Белый цвет (Red - 11, Green - 111, Blue - 111)
out 0x06           ; Устанавливаем цвет
[END_CODE]

Чтобы мы увидели изменение нужно поменять данные для переднего и заднего буфера местами

[BEGIN_CODE] [Смена буферов]
mvi A, 2           ; Режим - Смена буферов
out 0x06           ; Отправляем выбранный режим
[END_CODE]

[BEGIN_CODE] [Полная отчистка буферов]
mvi A, 3           ; Режим - Отчиска буферов
out 0x06           ; Отправляем выбранный режим
[END_CODE]

[BEGIN_CODE] [Чтение значение цвета пикселя из второго буфер]
mvi A, 1           ; Режим - чтение цвета пикселя
out 0x06           ; Отправляем выбранный режим
mvi A, 0x0F        ; номер строки пикселя  (Y)
out 0x06           ; запись номера строки
mvi A, 0x0F        ; номер столбца пикселя (X)
out 0x06           ; запись номера столбца
in 0x06            ; Получаем значение пикселя в регистр А
[END_CODE]
[END]



[BEGIN] [(0x07) Символьный экран]
#Порт:# 0x07
#Тип взаимодействия:# <Асинхронный>
#Разрешение:# 20x20
#Кол-во буферов:# 1 
#Кол-во цветов фона:# 8 (кодируются по упрощённой модели RGB[0bxxRGBxxx])
#Кол-во цветов текста:# 8 (кодируются по упрощённой модели RGB[0bxxxxxRGB])
#Кодировка символов:# ASCII 1251
#Окно для взаимодействия:# {Символьный экран}
#Вспомогающее окно:# {Все символы}

Протокол обмена информацией:
#1.# Записать в порт 0x07 номер строки символьного экрана (0 - 19).
#2.# Записать в порт 0x07 номер столбца символьного экрана (0 - 19).
#3.# Выбрать режим записи/чтения. (0x00 - запись, любое другое значение - чтение).
#4.# Записать/прочитать значение цвета фона и цвета символа выбранного пикселя экрана (цвет фона кодируется по упрощенной модели RGB. Пятым, четвёртым и третьим битами: 0bxxRGBxxx; цвет символа кодируется по упрощенной модели RGB вторым, первым и нулевым битами: (0bxxxxxRGB). Цвет фона и цвет пикселя передаются одним байтом.
#5.# Записать/прочитать значение кода символа выбранного пикселя экрана (Код символа таблицы ASCII 1251).

Пример вывода на экран символа '$' в зелёном цвете на синем фоне в пикселе с координатами [Row: 1, Column: 3]:

[BEGIN_CODE] [Запись цвета и символа]
mvi A, 0x01        ; номер строки пикселя
out 0x07           ; запись номера строки
mvi A, 0x03        ; номер столбца пикселя
out 0x07           ; запись номера столбца
mvi A, 0x00        ; загрузка нулевого значения в регистр (режим записи)
out 0x07           ; установка режима записи
mvi A, 0b00001010  ; загрузка кода цвета фона (0bxx001xxx - синий) и цвета символа (0bxxxxx010 - зелёный).
out 0x07           ; запись значения цвета фона и цвета символа
mvi A, 0x24        ; загрузка кода символа '$' согласно таблицы ASCII 1251
out 0x07           ; запись значения кода символа
[END_CODE]

[BEGIN_CODE] [Чтение значения символа и его цвета]
mvi A, 0x01        ; номер строки пикселя
out 0x07           ; запись номера строки
mvi A, 0x03        ; номер столбца пикселя
out 0x07           ; запись номера столбца
mvi A, 0x01        ; загрузка ненулевого значения в регистр (режим записи)
out 0x07           ; установка режима чтения
in 0x07 		   ; Значение цвета передаётся в регистр А
in 0x07 		   ; Значение символа передаётся в регистр А
[END_CODE]
[END]

[BEGIN] [(0x10) Клавиатура]
#Порт:# 0x10
#Тип взаимодействия:# <Асинхронный>
#Окно для взаимодействия:# {Клавиатура}

)"
u8R"(

Протокол обмена информацией:
#1.# Присваеваем нужное значение клавиши в регистр <A> (можно узнать в одноимённом окне)
#2.# Отправляем значение из регистра <A> в порт #0x10# (out 0x10)
#3.# Считываем в регистр <A> значение из порта #0x10# (in 0x10)

0 - #не зажата#
1 - #   зажата#

[BEGIN_CODE] [Пример чтение кнопки Z]
mvi a, 0x2a	; 0x2a - значение кнопки Z
out 0x10
in 0x10
hlt         ; Конец работы процессора
[END_CODE]
[END]

[BEGIN] [(0x16) Таймер]
#Порт:# 0x16
#Тип взаимодействия:# <Асинхронный>
#Максимальное значение:# 2.55 секунд
#Окно для взаимодействия:# {Таймер}

Протокол обмена информацией:
#*# С помощью out 0x16 производим запись нужного нам количества секунд. После выполнение инструкции таймер начинает уменьшать это значение в режиме реального времени. Устанавливаемое значение (INPUT) переводится в секунды по следующей формуле (Timer = INPUT * 0.01).
#*# С помощью in 0x16 производим чтение значения из таймера.

[BEGIN_CODE] [Установка]
mvi A, 100   ; Время 100 * 0.01 = 1.00 (секунда)
out 0x16     ; Заводим таймер на 1 секунду
[END_CODE]

[BEGIN_CODE] [Чтение]
in 0x16      ; Читаем оставшиеся время из таймера
[END_CODE]
[END]
[END]
)";